/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
/*
 * This file exports the `Node` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/library";
import type * as $Enums from "../enums.js";
import type * as Prisma from "../internal/prismaNamespace.js";

/**
 * Model Node
 *
 */
export type NodeModel =
	runtime.Types.Result.DefaultSelection<Prisma.$NodePayload>;

export type AggregateNode = {
	_count: NodeCountAggregateOutputType | null;
	_avg: NodeAvgAggregateOutputType | null;
	_sum: NodeSumAggregateOutputType | null;
	_min: NodeMinAggregateOutputType | null;
	_max: NodeMaxAggregateOutputType | null;
};

export type NodeAvgAggregateOutputType = {
	width: number | null;
	height: number | null;
};

export type NodeSumAggregateOutputType = {
	width: number | null;
	height: number | null;
};

export type NodeMinAggregateOutputType = {
	id: string | null;
	name: string | null;
	type: $Enums.NodeType | null;
	width: number | null;
	height: number | null;
	isDirty: boolean | null;
	createdAt: Date | null;
	updatedAt: Date | null;
	canvasId: string | null;
	templateId: string | null;
	originalNodeId: string | null;
};

export type NodeMaxAggregateOutputType = {
	id: string | null;
	name: string | null;
	type: $Enums.NodeType | null;
	width: number | null;
	height: number | null;
	isDirty: boolean | null;
	createdAt: Date | null;
	updatedAt: Date | null;
	canvasId: string | null;
	templateId: string | null;
	originalNodeId: string | null;
};

export type NodeCountAggregateOutputType = {
	id: number;
	name: number;
	type: number;
	position: number;
	width: number;
	height: number;
	config: number;
	isDirty: number;
	result: number;
	createdAt: number;
	updatedAt: number;
	canvasId: number;
	templateId: number;
	originalNodeId: number;
	_all: number;
};

export type NodeAvgAggregateInputType = {
	width?: true;
	height?: true;
};

export type NodeSumAggregateInputType = {
	width?: true;
	height?: true;
};

export type NodeMinAggregateInputType = {
	id?: true;
	name?: true;
	type?: true;
	width?: true;
	height?: true;
	isDirty?: true;
	createdAt?: true;
	updatedAt?: true;
	canvasId?: true;
	templateId?: true;
	originalNodeId?: true;
};

export type NodeMaxAggregateInputType = {
	id?: true;
	name?: true;
	type?: true;
	width?: true;
	height?: true;
	isDirty?: true;
	createdAt?: true;
	updatedAt?: true;
	canvasId?: true;
	templateId?: true;
	originalNodeId?: true;
};

export type NodeCountAggregateInputType = {
	id?: true;
	name?: true;
	type?: true;
	position?: true;
	width?: true;
	height?: true;
	config?: true;
	isDirty?: true;
	result?: true;
	createdAt?: true;
	updatedAt?: true;
	canvasId?: true;
	templateId?: true;
	originalNodeId?: true;
	_all?: true;
};

export type NodeAggregateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Filter which Node to aggregate.
	 */
	where?: Prisma.NodeWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Nodes to fetch.
	 */
	orderBy?:
		| Prisma.NodeOrderByWithRelationInput
		| Prisma.NodeOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the start position
	 */
	cursor?: Prisma.NodeWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Nodes from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Nodes.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Count returned Nodes
	 **/
	_count?: true | NodeCountAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to average
	 **/
	_avg?: NodeAvgAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to sum
	 **/
	_sum?: NodeSumAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to find the minimum value
	 **/
	_min?: NodeMinAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to find the maximum value
	 **/
	_max?: NodeMaxAggregateInputType;
};

export type GetNodeAggregateType<T extends NodeAggregateArgs> = {
	[P in keyof T & keyof AggregateNode]: P extends "_count" | "count"
		? T[P] extends true
			? number
			: Prisma.GetScalarType<T[P], AggregateNode[P]>
		: Prisma.GetScalarType<T[P], AggregateNode[P]>;
};

export type NodeGroupByArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.NodeWhereInput;
	orderBy?:
		| Prisma.NodeOrderByWithAggregationInput
		| Prisma.NodeOrderByWithAggregationInput[];
	by: Prisma.NodeScalarFieldEnum[] | Prisma.NodeScalarFieldEnum;
	having?: Prisma.NodeScalarWhereWithAggregatesInput;
	take?: number;
	skip?: number;
	_count?: NodeCountAggregateInputType | true;
	_avg?: NodeAvgAggregateInputType;
	_sum?: NodeSumAggregateInputType;
	_min?: NodeMinAggregateInputType;
	_max?: NodeMaxAggregateInputType;
};

export type NodeGroupByOutputType = {
	id: string;
	name: string;
	type: $Enums.NodeType;
	position: runtime.JsonValue;
	width: number | null;
	height: number | null;
	config: runtime.JsonValue | null;
	isDirty: boolean;
	result: runtime.JsonValue | null;
	createdAt: Date;
	updatedAt: Date;
	canvasId: string;
	templateId: string;
	originalNodeId: string | null;
	_count: NodeCountAggregateOutputType | null;
	_avg: NodeAvgAggregateOutputType | null;
	_sum: NodeSumAggregateOutputType | null;
	_min: NodeMinAggregateOutputType | null;
	_max: NodeMaxAggregateOutputType | null;
};

type GetNodeGroupByPayload<T extends NodeGroupByArgs> = Prisma.PrismaPromise<
	Array<
		Prisma.PickEnumerable<NodeGroupByOutputType, T["by"]> & {
			[P in keyof T & keyof NodeGroupByOutputType]: P extends "_count"
				? T[P] extends boolean
					? number
					: Prisma.GetScalarType<T[P], NodeGroupByOutputType[P]>
				: Prisma.GetScalarType<T[P], NodeGroupByOutputType[P]>;
		}
	>
>;

export type NodeWhereInput = {
	AND?: Prisma.NodeWhereInput | Prisma.NodeWhereInput[];
	OR?: Prisma.NodeWhereInput[];
	NOT?: Prisma.NodeWhereInput | Prisma.NodeWhereInput[];
	id?: Prisma.StringFilter<"Node"> | string;
	name?: Prisma.StringFilter<"Node"> | string;
	type?: Prisma.EnumNodeTypeFilter<"Node"> | $Enums.NodeType;
	position?: Prisma.JsonFilter<"Node">;
	width?: Prisma.FloatNullableFilter<"Node"> | number | null;
	height?: Prisma.FloatNullableFilter<"Node"> | number | null;
	config?: Prisma.JsonNullableFilter<"Node">;
	isDirty?: Prisma.BoolFilter<"Node"> | boolean;
	result?: Prisma.JsonNullableFilter<"Node">;
	createdAt?: Prisma.DateTimeFilter<"Node"> | Date | string;
	updatedAt?: Prisma.DateTimeFilter<"Node"> | Date | string;
	canvasId?: Prisma.StringFilter<"Node"> | string;
	templateId?: Prisma.StringFilter<"Node"> | string;
	originalNodeId?: Prisma.StringNullableFilter<"Node"> | string | null;
	handles?: Prisma.HandleListRelationFilter;
	edgesFrom?: Prisma.EdgeListRelationFilter;
	edgesTo?: Prisma.EdgeListRelationFilter;
	canvas?: Prisma.XOR<
		Prisma.CanvasScalarRelationFilter,
		Prisma.CanvasWhereInput
	>;
	tasks?: Prisma.TaskListRelationFilter;
	template?: Prisma.XOR<
		Prisma.NodeTemplateScalarRelationFilter,
		Prisma.NodeTemplateWhereInput
	>;
	originalNode?: Prisma.XOR<
		Prisma.NodeNullableScalarRelationFilter,
		Prisma.NodeWhereInput
	> | null;
	duplicates?: Prisma.NodeListRelationFilter;
};

export type NodeOrderByWithRelationInput = {
	id?: Prisma.SortOrder;
	name?: Prisma.SortOrder;
	type?: Prisma.SortOrder;
	position?: Prisma.SortOrder;
	width?: Prisma.SortOrderInput | Prisma.SortOrder;
	height?: Prisma.SortOrderInput | Prisma.SortOrder;
	config?: Prisma.SortOrderInput | Prisma.SortOrder;
	isDirty?: Prisma.SortOrder;
	result?: Prisma.SortOrderInput | Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrder;
	canvasId?: Prisma.SortOrder;
	templateId?: Prisma.SortOrder;
	originalNodeId?: Prisma.SortOrderInput | Prisma.SortOrder;
	handles?: Prisma.HandleOrderByRelationAggregateInput;
	edgesFrom?: Prisma.EdgeOrderByRelationAggregateInput;
	edgesTo?: Prisma.EdgeOrderByRelationAggregateInput;
	canvas?: Prisma.CanvasOrderByWithRelationInput;
	tasks?: Prisma.TaskOrderByRelationAggregateInput;
	template?: Prisma.NodeTemplateOrderByWithRelationInput;
	originalNode?: Prisma.NodeOrderByWithRelationInput;
	duplicates?: Prisma.NodeOrderByRelationAggregateInput;
};

export type NodeWhereUniqueInput = Prisma.AtLeast<
	{
		id?: string;
		AND?: Prisma.NodeWhereInput | Prisma.NodeWhereInput[];
		OR?: Prisma.NodeWhereInput[];
		NOT?: Prisma.NodeWhereInput | Prisma.NodeWhereInput[];
		name?: Prisma.StringFilter<"Node"> | string;
		type?: Prisma.EnumNodeTypeFilter<"Node"> | $Enums.NodeType;
		position?: Prisma.JsonFilter<"Node">;
		width?: Prisma.FloatNullableFilter<"Node"> | number | null;
		height?: Prisma.FloatNullableFilter<"Node"> | number | null;
		config?: Prisma.JsonNullableFilter<"Node">;
		isDirty?: Prisma.BoolFilter<"Node"> | boolean;
		result?: Prisma.JsonNullableFilter<"Node">;
		createdAt?: Prisma.DateTimeFilter<"Node"> | Date | string;
		updatedAt?: Prisma.DateTimeFilter<"Node"> | Date | string;
		canvasId?: Prisma.StringFilter<"Node"> | string;
		templateId?: Prisma.StringFilter<"Node"> | string;
		originalNodeId?: Prisma.StringNullableFilter<"Node"> | string | null;
		handles?: Prisma.HandleListRelationFilter;
		edgesFrom?: Prisma.EdgeListRelationFilter;
		edgesTo?: Prisma.EdgeListRelationFilter;
		canvas?: Prisma.XOR<
			Prisma.CanvasScalarRelationFilter,
			Prisma.CanvasWhereInput
		>;
		tasks?: Prisma.TaskListRelationFilter;
		template?: Prisma.XOR<
			Prisma.NodeTemplateScalarRelationFilter,
			Prisma.NodeTemplateWhereInput
		>;
		originalNode?: Prisma.XOR<
			Prisma.NodeNullableScalarRelationFilter,
			Prisma.NodeWhereInput
		> | null;
		duplicates?: Prisma.NodeListRelationFilter;
	},
	"id"
>;

export type NodeOrderByWithAggregationInput = {
	id?: Prisma.SortOrder;
	name?: Prisma.SortOrder;
	type?: Prisma.SortOrder;
	position?: Prisma.SortOrder;
	width?: Prisma.SortOrderInput | Prisma.SortOrder;
	height?: Prisma.SortOrderInput | Prisma.SortOrder;
	config?: Prisma.SortOrderInput | Prisma.SortOrder;
	isDirty?: Prisma.SortOrder;
	result?: Prisma.SortOrderInput | Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrder;
	canvasId?: Prisma.SortOrder;
	templateId?: Prisma.SortOrder;
	originalNodeId?: Prisma.SortOrderInput | Prisma.SortOrder;
	_count?: Prisma.NodeCountOrderByAggregateInput;
	_avg?: Prisma.NodeAvgOrderByAggregateInput;
	_max?: Prisma.NodeMaxOrderByAggregateInput;
	_min?: Prisma.NodeMinOrderByAggregateInput;
	_sum?: Prisma.NodeSumOrderByAggregateInput;
};

export type NodeScalarWhereWithAggregatesInput = {
	AND?:
		| Prisma.NodeScalarWhereWithAggregatesInput
		| Prisma.NodeScalarWhereWithAggregatesInput[];
	OR?: Prisma.NodeScalarWhereWithAggregatesInput[];
	NOT?:
		| Prisma.NodeScalarWhereWithAggregatesInput
		| Prisma.NodeScalarWhereWithAggregatesInput[];
	id?: Prisma.StringWithAggregatesFilter<"Node"> | string;
	name?: Prisma.StringWithAggregatesFilter<"Node"> | string;
	type?: Prisma.EnumNodeTypeWithAggregatesFilter<"Node"> | $Enums.NodeType;
	position?: Prisma.JsonWithAggregatesFilter<"Node">;
	width?: Prisma.FloatNullableWithAggregatesFilter<"Node"> | number | null;
	height?: Prisma.FloatNullableWithAggregatesFilter<"Node"> | number | null;
	config?: Prisma.JsonNullableWithAggregatesFilter<"Node">;
	isDirty?: Prisma.BoolWithAggregatesFilter<"Node"> | boolean;
	result?: Prisma.JsonNullableWithAggregatesFilter<"Node">;
	createdAt?: Prisma.DateTimeWithAggregatesFilter<"Node"> | Date | string;
	updatedAt?: Prisma.DateTimeWithAggregatesFilter<"Node"> | Date | string;
	canvasId?: Prisma.StringWithAggregatesFilter<"Node"> | string;
	templateId?: Prisma.StringWithAggregatesFilter<"Node"> | string;
	originalNodeId?:
		| Prisma.StringNullableWithAggregatesFilter<"Node">
		| string
		| null;
};

export type NodeCreateInput = {
	id?: string;
	name: string;
	type: $Enums.NodeType;
	position: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: number | null;
	height?: number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	handles?: Prisma.HandleCreateNestedManyWithoutNodeInput;
	edgesFrom?: Prisma.EdgeCreateNestedManyWithoutSourceNodeInput;
	edgesTo?: Prisma.EdgeCreateNestedManyWithoutTargetNodeInput;
	canvas: Prisma.CanvasCreateNestedOneWithoutNodesInput;
	tasks?: Prisma.TaskCreateNestedManyWithoutNodeInput;
	template: Prisma.NodeTemplateCreateNestedOneWithoutNodesInput;
	originalNode?: Prisma.NodeCreateNestedOneWithoutDuplicatesInput;
	duplicates?: Prisma.NodeCreateNestedManyWithoutOriginalNodeInput;
};

export type NodeUncheckedCreateInput = {
	id?: string;
	name: string;
	type: $Enums.NodeType;
	position: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: number | null;
	height?: number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	canvasId: string;
	templateId: string;
	originalNodeId?: string | null;
	handles?: Prisma.HandleUncheckedCreateNestedManyWithoutNodeInput;
	edgesFrom?: Prisma.EdgeUncheckedCreateNestedManyWithoutSourceNodeInput;
	edgesTo?: Prisma.EdgeUncheckedCreateNestedManyWithoutTargetNodeInput;
	tasks?: Prisma.TaskUncheckedCreateNestedManyWithoutNodeInput;
	duplicates?: Prisma.NodeUncheckedCreateNestedManyWithoutOriginalNodeInput;
};

export type NodeUpdateInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?: Prisma.EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType;
	position?: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	height?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	handles?: Prisma.HandleUpdateManyWithoutNodeNestedInput;
	edgesFrom?: Prisma.EdgeUpdateManyWithoutSourceNodeNestedInput;
	edgesTo?: Prisma.EdgeUpdateManyWithoutTargetNodeNestedInput;
	canvas?: Prisma.CanvasUpdateOneRequiredWithoutNodesNestedInput;
	tasks?: Prisma.TaskUpdateManyWithoutNodeNestedInput;
	template?: Prisma.NodeTemplateUpdateOneRequiredWithoutNodesNestedInput;
	originalNode?: Prisma.NodeUpdateOneWithoutDuplicatesNestedInput;
	duplicates?: Prisma.NodeUpdateManyWithoutOriginalNodeNestedInput;
};

export type NodeUncheckedUpdateInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?: Prisma.EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType;
	position?: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	height?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	canvasId?: Prisma.StringFieldUpdateOperationsInput | string;
	templateId?: Prisma.StringFieldUpdateOperationsInput | string;
	originalNodeId?:
		| Prisma.NullableStringFieldUpdateOperationsInput
		| string
		| null;
	handles?: Prisma.HandleUncheckedUpdateManyWithoutNodeNestedInput;
	edgesFrom?: Prisma.EdgeUncheckedUpdateManyWithoutSourceNodeNestedInput;
	edgesTo?: Prisma.EdgeUncheckedUpdateManyWithoutTargetNodeNestedInput;
	tasks?: Prisma.TaskUncheckedUpdateManyWithoutNodeNestedInput;
	duplicates?: Prisma.NodeUncheckedUpdateManyWithoutOriginalNodeNestedInput;
};

export type NodeCreateManyInput = {
	id?: string;
	name: string;
	type: $Enums.NodeType;
	position: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: number | null;
	height?: number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	canvasId: string;
	templateId: string;
	originalNodeId?: string | null;
};

export type NodeUpdateManyMutationInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?: Prisma.EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType;
	position?: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	height?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type NodeUncheckedUpdateManyInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?: Prisma.EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType;
	position?: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	height?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	canvasId?: Prisma.StringFieldUpdateOperationsInput | string;
	templateId?: Prisma.StringFieldUpdateOperationsInput | string;
	originalNodeId?:
		| Prisma.NullableStringFieldUpdateOperationsInput
		| string
		| null;
};

export type NodeListRelationFilter = {
	every?: Prisma.NodeWhereInput;
	some?: Prisma.NodeWhereInput;
	none?: Prisma.NodeWhereInput;
};

export type NodeOrderByRelationAggregateInput = {
	_count?: Prisma.SortOrder;
};

export type NodeNullableScalarRelationFilter = {
	is?: Prisma.NodeWhereInput | null;
	isNot?: Prisma.NodeWhereInput | null;
};

export type NodeCountOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	name?: Prisma.SortOrder;
	type?: Prisma.SortOrder;
	position?: Prisma.SortOrder;
	width?: Prisma.SortOrder;
	height?: Prisma.SortOrder;
	config?: Prisma.SortOrder;
	isDirty?: Prisma.SortOrder;
	result?: Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrder;
	canvasId?: Prisma.SortOrder;
	templateId?: Prisma.SortOrder;
	originalNodeId?: Prisma.SortOrder;
};

export type NodeAvgOrderByAggregateInput = {
	width?: Prisma.SortOrder;
	height?: Prisma.SortOrder;
};

export type NodeMaxOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	name?: Prisma.SortOrder;
	type?: Prisma.SortOrder;
	width?: Prisma.SortOrder;
	height?: Prisma.SortOrder;
	isDirty?: Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrder;
	canvasId?: Prisma.SortOrder;
	templateId?: Prisma.SortOrder;
	originalNodeId?: Prisma.SortOrder;
};

export type NodeMinOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	name?: Prisma.SortOrder;
	type?: Prisma.SortOrder;
	width?: Prisma.SortOrder;
	height?: Prisma.SortOrder;
	isDirty?: Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrder;
	canvasId?: Prisma.SortOrder;
	templateId?: Prisma.SortOrder;
	originalNodeId?: Prisma.SortOrder;
};

export type NodeSumOrderByAggregateInput = {
	width?: Prisma.SortOrder;
	height?: Prisma.SortOrder;
};

export type NodeScalarRelationFilter = {
	is?: Prisma.NodeWhereInput;
	isNot?: Prisma.NodeWhereInput;
};

export type NodeCreateNestedManyWithoutCanvasInput = {
	create?:
		| Prisma.XOR<
				Prisma.NodeCreateWithoutCanvasInput,
				Prisma.NodeUncheckedCreateWithoutCanvasInput
		  >
		| Prisma.NodeCreateWithoutCanvasInput[]
		| Prisma.NodeUncheckedCreateWithoutCanvasInput[];
	connectOrCreate?:
		| Prisma.NodeCreateOrConnectWithoutCanvasInput
		| Prisma.NodeCreateOrConnectWithoutCanvasInput[];
	createMany?: Prisma.NodeCreateManyCanvasInputEnvelope;
	connect?: Prisma.NodeWhereUniqueInput | Prisma.NodeWhereUniqueInput[];
};

export type NodeUncheckedCreateNestedManyWithoutCanvasInput = {
	create?:
		| Prisma.XOR<
				Prisma.NodeCreateWithoutCanvasInput,
				Prisma.NodeUncheckedCreateWithoutCanvasInput
		  >
		| Prisma.NodeCreateWithoutCanvasInput[]
		| Prisma.NodeUncheckedCreateWithoutCanvasInput[];
	connectOrCreate?:
		| Prisma.NodeCreateOrConnectWithoutCanvasInput
		| Prisma.NodeCreateOrConnectWithoutCanvasInput[];
	createMany?: Prisma.NodeCreateManyCanvasInputEnvelope;
	connect?: Prisma.NodeWhereUniqueInput | Prisma.NodeWhereUniqueInput[];
};

export type NodeUpdateManyWithoutCanvasNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.NodeCreateWithoutCanvasInput,
				Prisma.NodeUncheckedCreateWithoutCanvasInput
		  >
		| Prisma.NodeCreateWithoutCanvasInput[]
		| Prisma.NodeUncheckedCreateWithoutCanvasInput[];
	connectOrCreate?:
		| Prisma.NodeCreateOrConnectWithoutCanvasInput
		| Prisma.NodeCreateOrConnectWithoutCanvasInput[];
	upsert?:
		| Prisma.NodeUpsertWithWhereUniqueWithoutCanvasInput
		| Prisma.NodeUpsertWithWhereUniqueWithoutCanvasInput[];
	createMany?: Prisma.NodeCreateManyCanvasInputEnvelope;
	set?: Prisma.NodeWhereUniqueInput | Prisma.NodeWhereUniqueInput[];
	disconnect?: Prisma.NodeWhereUniqueInput | Prisma.NodeWhereUniqueInput[];
	delete?: Prisma.NodeWhereUniqueInput | Prisma.NodeWhereUniqueInput[];
	connect?: Prisma.NodeWhereUniqueInput | Prisma.NodeWhereUniqueInput[];
	update?:
		| Prisma.NodeUpdateWithWhereUniqueWithoutCanvasInput
		| Prisma.NodeUpdateWithWhereUniqueWithoutCanvasInput[];
	updateMany?:
		| Prisma.NodeUpdateManyWithWhereWithoutCanvasInput
		| Prisma.NodeUpdateManyWithWhereWithoutCanvasInput[];
	deleteMany?: Prisma.NodeScalarWhereInput | Prisma.NodeScalarWhereInput[];
};

export type NodeUncheckedUpdateManyWithoutCanvasNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.NodeCreateWithoutCanvasInput,
				Prisma.NodeUncheckedCreateWithoutCanvasInput
		  >
		| Prisma.NodeCreateWithoutCanvasInput[]
		| Prisma.NodeUncheckedCreateWithoutCanvasInput[];
	connectOrCreate?:
		| Prisma.NodeCreateOrConnectWithoutCanvasInput
		| Prisma.NodeCreateOrConnectWithoutCanvasInput[];
	upsert?:
		| Prisma.NodeUpsertWithWhereUniqueWithoutCanvasInput
		| Prisma.NodeUpsertWithWhereUniqueWithoutCanvasInput[];
	createMany?: Prisma.NodeCreateManyCanvasInputEnvelope;
	set?: Prisma.NodeWhereUniqueInput | Prisma.NodeWhereUniqueInput[];
	disconnect?: Prisma.NodeWhereUniqueInput | Prisma.NodeWhereUniqueInput[];
	delete?: Prisma.NodeWhereUniqueInput | Prisma.NodeWhereUniqueInput[];
	connect?: Prisma.NodeWhereUniqueInput | Prisma.NodeWhereUniqueInput[];
	update?:
		| Prisma.NodeUpdateWithWhereUniqueWithoutCanvasInput
		| Prisma.NodeUpdateWithWhereUniqueWithoutCanvasInput[];
	updateMany?:
		| Prisma.NodeUpdateManyWithWhereWithoutCanvasInput
		| Prisma.NodeUpdateManyWithWhereWithoutCanvasInput[];
	deleteMany?: Prisma.NodeScalarWhereInput | Prisma.NodeScalarWhereInput[];
};

export type NodeCreateNestedOneWithoutDuplicatesInput = {
	create?: Prisma.XOR<
		Prisma.NodeCreateWithoutDuplicatesInput,
		Prisma.NodeUncheckedCreateWithoutDuplicatesInput
	>;
	connectOrCreate?: Prisma.NodeCreateOrConnectWithoutDuplicatesInput;
	connect?: Prisma.NodeWhereUniqueInput;
};

export type NodeCreateNestedManyWithoutOriginalNodeInput = {
	create?:
		| Prisma.XOR<
				Prisma.NodeCreateWithoutOriginalNodeInput,
				Prisma.NodeUncheckedCreateWithoutOriginalNodeInput
		  >
		| Prisma.NodeCreateWithoutOriginalNodeInput[]
		| Prisma.NodeUncheckedCreateWithoutOriginalNodeInput[];
	connectOrCreate?:
		| Prisma.NodeCreateOrConnectWithoutOriginalNodeInput
		| Prisma.NodeCreateOrConnectWithoutOriginalNodeInput[];
	createMany?: Prisma.NodeCreateManyOriginalNodeInputEnvelope;
	connect?: Prisma.NodeWhereUniqueInput | Prisma.NodeWhereUniqueInput[];
};

export type NodeUncheckedCreateNestedManyWithoutOriginalNodeInput = {
	create?:
		| Prisma.XOR<
				Prisma.NodeCreateWithoutOriginalNodeInput,
				Prisma.NodeUncheckedCreateWithoutOriginalNodeInput
		  >
		| Prisma.NodeCreateWithoutOriginalNodeInput[]
		| Prisma.NodeUncheckedCreateWithoutOriginalNodeInput[];
	connectOrCreate?:
		| Prisma.NodeCreateOrConnectWithoutOriginalNodeInput
		| Prisma.NodeCreateOrConnectWithoutOriginalNodeInput[];
	createMany?: Prisma.NodeCreateManyOriginalNodeInputEnvelope;
	connect?: Prisma.NodeWhereUniqueInput | Prisma.NodeWhereUniqueInput[];
};

export type EnumNodeTypeFieldUpdateOperationsInput = {
	set?: $Enums.NodeType;
};

export type NullableFloatFieldUpdateOperationsInput = {
	set?: number | null;
	increment?: number;
	decrement?: number;
	multiply?: number;
	divide?: number;
};

export type NodeUpdateOneWithoutDuplicatesNestedInput = {
	create?: Prisma.XOR<
		Prisma.NodeCreateWithoutDuplicatesInput,
		Prisma.NodeUncheckedCreateWithoutDuplicatesInput
	>;
	connectOrCreate?: Prisma.NodeCreateOrConnectWithoutDuplicatesInput;
	upsert?: Prisma.NodeUpsertWithoutDuplicatesInput;
	disconnect?: Prisma.NodeWhereInput | boolean;
	delete?: Prisma.NodeWhereInput | boolean;
	connect?: Prisma.NodeWhereUniqueInput;
	update?: Prisma.XOR<
		Prisma.XOR<
			Prisma.NodeUpdateToOneWithWhereWithoutDuplicatesInput,
			Prisma.NodeUpdateWithoutDuplicatesInput
		>,
		Prisma.NodeUncheckedUpdateWithoutDuplicatesInput
	>;
};

export type NodeUpdateManyWithoutOriginalNodeNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.NodeCreateWithoutOriginalNodeInput,
				Prisma.NodeUncheckedCreateWithoutOriginalNodeInput
		  >
		| Prisma.NodeCreateWithoutOriginalNodeInput[]
		| Prisma.NodeUncheckedCreateWithoutOriginalNodeInput[];
	connectOrCreate?:
		| Prisma.NodeCreateOrConnectWithoutOriginalNodeInput
		| Prisma.NodeCreateOrConnectWithoutOriginalNodeInput[];
	upsert?:
		| Prisma.NodeUpsertWithWhereUniqueWithoutOriginalNodeInput
		| Prisma.NodeUpsertWithWhereUniqueWithoutOriginalNodeInput[];
	createMany?: Prisma.NodeCreateManyOriginalNodeInputEnvelope;
	set?: Prisma.NodeWhereUniqueInput | Prisma.NodeWhereUniqueInput[];
	disconnect?: Prisma.NodeWhereUniqueInput | Prisma.NodeWhereUniqueInput[];
	delete?: Prisma.NodeWhereUniqueInput | Prisma.NodeWhereUniqueInput[];
	connect?: Prisma.NodeWhereUniqueInput | Prisma.NodeWhereUniqueInput[];
	update?:
		| Prisma.NodeUpdateWithWhereUniqueWithoutOriginalNodeInput
		| Prisma.NodeUpdateWithWhereUniqueWithoutOriginalNodeInput[];
	updateMany?:
		| Prisma.NodeUpdateManyWithWhereWithoutOriginalNodeInput
		| Prisma.NodeUpdateManyWithWhereWithoutOriginalNodeInput[];
	deleteMany?: Prisma.NodeScalarWhereInput | Prisma.NodeScalarWhereInput[];
};

export type NodeUncheckedUpdateManyWithoutOriginalNodeNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.NodeCreateWithoutOriginalNodeInput,
				Prisma.NodeUncheckedCreateWithoutOriginalNodeInput
		  >
		| Prisma.NodeCreateWithoutOriginalNodeInput[]
		| Prisma.NodeUncheckedCreateWithoutOriginalNodeInput[];
	connectOrCreate?:
		| Prisma.NodeCreateOrConnectWithoutOriginalNodeInput
		| Prisma.NodeCreateOrConnectWithoutOriginalNodeInput[];
	upsert?:
		| Prisma.NodeUpsertWithWhereUniqueWithoutOriginalNodeInput
		| Prisma.NodeUpsertWithWhereUniqueWithoutOriginalNodeInput[];
	createMany?: Prisma.NodeCreateManyOriginalNodeInputEnvelope;
	set?: Prisma.NodeWhereUniqueInput | Prisma.NodeWhereUniqueInput[];
	disconnect?: Prisma.NodeWhereUniqueInput | Prisma.NodeWhereUniqueInput[];
	delete?: Prisma.NodeWhereUniqueInput | Prisma.NodeWhereUniqueInput[];
	connect?: Prisma.NodeWhereUniqueInput | Prisma.NodeWhereUniqueInput[];
	update?:
		| Prisma.NodeUpdateWithWhereUniqueWithoutOriginalNodeInput
		| Prisma.NodeUpdateWithWhereUniqueWithoutOriginalNodeInput[];
	updateMany?:
		| Prisma.NodeUpdateManyWithWhereWithoutOriginalNodeInput
		| Prisma.NodeUpdateManyWithWhereWithoutOriginalNodeInput[];
	deleteMany?: Prisma.NodeScalarWhereInput | Prisma.NodeScalarWhereInput[];
};

export type NodeCreateNestedOneWithoutHandlesInput = {
	create?: Prisma.XOR<
		Prisma.NodeCreateWithoutHandlesInput,
		Prisma.NodeUncheckedCreateWithoutHandlesInput
	>;
	connectOrCreate?: Prisma.NodeCreateOrConnectWithoutHandlesInput;
	connect?: Prisma.NodeWhereUniqueInput;
};

export type NodeUpdateOneRequiredWithoutHandlesNestedInput = {
	create?: Prisma.XOR<
		Prisma.NodeCreateWithoutHandlesInput,
		Prisma.NodeUncheckedCreateWithoutHandlesInput
	>;
	connectOrCreate?: Prisma.NodeCreateOrConnectWithoutHandlesInput;
	upsert?: Prisma.NodeUpsertWithoutHandlesInput;
	connect?: Prisma.NodeWhereUniqueInput;
	update?: Prisma.XOR<
		Prisma.XOR<
			Prisma.NodeUpdateToOneWithWhereWithoutHandlesInput,
			Prisma.NodeUpdateWithoutHandlesInput
		>,
		Prisma.NodeUncheckedUpdateWithoutHandlesInput
	>;
};

export type NodeCreateNestedManyWithoutTemplateInput = {
	create?:
		| Prisma.XOR<
				Prisma.NodeCreateWithoutTemplateInput,
				Prisma.NodeUncheckedCreateWithoutTemplateInput
		  >
		| Prisma.NodeCreateWithoutTemplateInput[]
		| Prisma.NodeUncheckedCreateWithoutTemplateInput[];
	connectOrCreate?:
		| Prisma.NodeCreateOrConnectWithoutTemplateInput
		| Prisma.NodeCreateOrConnectWithoutTemplateInput[];
	createMany?: Prisma.NodeCreateManyTemplateInputEnvelope;
	connect?: Prisma.NodeWhereUniqueInput | Prisma.NodeWhereUniqueInput[];
};

export type NodeUncheckedCreateNestedManyWithoutTemplateInput = {
	create?:
		| Prisma.XOR<
				Prisma.NodeCreateWithoutTemplateInput,
				Prisma.NodeUncheckedCreateWithoutTemplateInput
		  >
		| Prisma.NodeCreateWithoutTemplateInput[]
		| Prisma.NodeUncheckedCreateWithoutTemplateInput[];
	connectOrCreate?:
		| Prisma.NodeCreateOrConnectWithoutTemplateInput
		| Prisma.NodeCreateOrConnectWithoutTemplateInput[];
	createMany?: Prisma.NodeCreateManyTemplateInputEnvelope;
	connect?: Prisma.NodeWhereUniqueInput | Prisma.NodeWhereUniqueInput[];
};

export type NodeUpdateManyWithoutTemplateNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.NodeCreateWithoutTemplateInput,
				Prisma.NodeUncheckedCreateWithoutTemplateInput
		  >
		| Prisma.NodeCreateWithoutTemplateInput[]
		| Prisma.NodeUncheckedCreateWithoutTemplateInput[];
	connectOrCreate?:
		| Prisma.NodeCreateOrConnectWithoutTemplateInput
		| Prisma.NodeCreateOrConnectWithoutTemplateInput[];
	upsert?:
		| Prisma.NodeUpsertWithWhereUniqueWithoutTemplateInput
		| Prisma.NodeUpsertWithWhereUniqueWithoutTemplateInput[];
	createMany?: Prisma.NodeCreateManyTemplateInputEnvelope;
	set?: Prisma.NodeWhereUniqueInput | Prisma.NodeWhereUniqueInput[];
	disconnect?: Prisma.NodeWhereUniqueInput | Prisma.NodeWhereUniqueInput[];
	delete?: Prisma.NodeWhereUniqueInput | Prisma.NodeWhereUniqueInput[];
	connect?: Prisma.NodeWhereUniqueInput | Prisma.NodeWhereUniqueInput[];
	update?:
		| Prisma.NodeUpdateWithWhereUniqueWithoutTemplateInput
		| Prisma.NodeUpdateWithWhereUniqueWithoutTemplateInput[];
	updateMany?:
		| Prisma.NodeUpdateManyWithWhereWithoutTemplateInput
		| Prisma.NodeUpdateManyWithWhereWithoutTemplateInput[];
	deleteMany?: Prisma.NodeScalarWhereInput | Prisma.NodeScalarWhereInput[];
};

export type NodeUncheckedUpdateManyWithoutTemplateNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.NodeCreateWithoutTemplateInput,
				Prisma.NodeUncheckedCreateWithoutTemplateInput
		  >
		| Prisma.NodeCreateWithoutTemplateInput[]
		| Prisma.NodeUncheckedCreateWithoutTemplateInput[];
	connectOrCreate?:
		| Prisma.NodeCreateOrConnectWithoutTemplateInput
		| Prisma.NodeCreateOrConnectWithoutTemplateInput[];
	upsert?:
		| Prisma.NodeUpsertWithWhereUniqueWithoutTemplateInput
		| Prisma.NodeUpsertWithWhereUniqueWithoutTemplateInput[];
	createMany?: Prisma.NodeCreateManyTemplateInputEnvelope;
	set?: Prisma.NodeWhereUniqueInput | Prisma.NodeWhereUniqueInput[];
	disconnect?: Prisma.NodeWhereUniqueInput | Prisma.NodeWhereUniqueInput[];
	delete?: Prisma.NodeWhereUniqueInput | Prisma.NodeWhereUniqueInput[];
	connect?: Prisma.NodeWhereUniqueInput | Prisma.NodeWhereUniqueInput[];
	update?:
		| Prisma.NodeUpdateWithWhereUniqueWithoutTemplateInput
		| Prisma.NodeUpdateWithWhereUniqueWithoutTemplateInput[];
	updateMany?:
		| Prisma.NodeUpdateManyWithWhereWithoutTemplateInput
		| Prisma.NodeUpdateManyWithWhereWithoutTemplateInput[];
	deleteMany?: Prisma.NodeScalarWhereInput | Prisma.NodeScalarWhereInput[];
};

export type NodeCreateNestedOneWithoutEdgesFromInput = {
	create?: Prisma.XOR<
		Prisma.NodeCreateWithoutEdgesFromInput,
		Prisma.NodeUncheckedCreateWithoutEdgesFromInput
	>;
	connectOrCreate?: Prisma.NodeCreateOrConnectWithoutEdgesFromInput;
	connect?: Prisma.NodeWhereUniqueInput;
};

export type NodeCreateNestedOneWithoutEdgesToInput = {
	create?: Prisma.XOR<
		Prisma.NodeCreateWithoutEdgesToInput,
		Prisma.NodeUncheckedCreateWithoutEdgesToInput
	>;
	connectOrCreate?: Prisma.NodeCreateOrConnectWithoutEdgesToInput;
	connect?: Prisma.NodeWhereUniqueInput;
};

export type NodeUpdateOneRequiredWithoutEdgesFromNestedInput = {
	create?: Prisma.XOR<
		Prisma.NodeCreateWithoutEdgesFromInput,
		Prisma.NodeUncheckedCreateWithoutEdgesFromInput
	>;
	connectOrCreate?: Prisma.NodeCreateOrConnectWithoutEdgesFromInput;
	upsert?: Prisma.NodeUpsertWithoutEdgesFromInput;
	connect?: Prisma.NodeWhereUniqueInput;
	update?: Prisma.XOR<
		Prisma.XOR<
			Prisma.NodeUpdateToOneWithWhereWithoutEdgesFromInput,
			Prisma.NodeUpdateWithoutEdgesFromInput
		>,
		Prisma.NodeUncheckedUpdateWithoutEdgesFromInput
	>;
};

export type NodeUpdateOneRequiredWithoutEdgesToNestedInput = {
	create?: Prisma.XOR<
		Prisma.NodeCreateWithoutEdgesToInput,
		Prisma.NodeUncheckedCreateWithoutEdgesToInput
	>;
	connectOrCreate?: Prisma.NodeCreateOrConnectWithoutEdgesToInput;
	upsert?: Prisma.NodeUpsertWithoutEdgesToInput;
	connect?: Prisma.NodeWhereUniqueInput;
	update?: Prisma.XOR<
		Prisma.XOR<
			Prisma.NodeUpdateToOneWithWhereWithoutEdgesToInput,
			Prisma.NodeUpdateWithoutEdgesToInput
		>,
		Prisma.NodeUncheckedUpdateWithoutEdgesToInput
	>;
};

export type NodeCreateNestedOneWithoutTasksInput = {
	create?: Prisma.XOR<
		Prisma.NodeCreateWithoutTasksInput,
		Prisma.NodeUncheckedCreateWithoutTasksInput
	>;
	connectOrCreate?: Prisma.NodeCreateOrConnectWithoutTasksInput;
	connect?: Prisma.NodeWhereUniqueInput;
};

export type NodeUpdateOneWithoutTasksNestedInput = {
	create?: Prisma.XOR<
		Prisma.NodeCreateWithoutTasksInput,
		Prisma.NodeUncheckedCreateWithoutTasksInput
	>;
	connectOrCreate?: Prisma.NodeCreateOrConnectWithoutTasksInput;
	upsert?: Prisma.NodeUpsertWithoutTasksInput;
	disconnect?: Prisma.NodeWhereInput | boolean;
	delete?: Prisma.NodeWhereInput | boolean;
	connect?: Prisma.NodeWhereUniqueInput;
	update?: Prisma.XOR<
		Prisma.XOR<
			Prisma.NodeUpdateToOneWithWhereWithoutTasksInput,
			Prisma.NodeUpdateWithoutTasksInput
		>,
		Prisma.NodeUncheckedUpdateWithoutTasksInput
	>;
};

export type NodeCreateWithoutCanvasInput = {
	id?: string;
	name: string;
	type: $Enums.NodeType;
	position: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: number | null;
	height?: number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	handles?: Prisma.HandleCreateNestedManyWithoutNodeInput;
	edgesFrom?: Prisma.EdgeCreateNestedManyWithoutSourceNodeInput;
	edgesTo?: Prisma.EdgeCreateNestedManyWithoutTargetNodeInput;
	tasks?: Prisma.TaskCreateNestedManyWithoutNodeInput;
	template: Prisma.NodeTemplateCreateNestedOneWithoutNodesInput;
	originalNode?: Prisma.NodeCreateNestedOneWithoutDuplicatesInput;
	duplicates?: Prisma.NodeCreateNestedManyWithoutOriginalNodeInput;
};

export type NodeUncheckedCreateWithoutCanvasInput = {
	id?: string;
	name: string;
	type: $Enums.NodeType;
	position: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: number | null;
	height?: number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	templateId: string;
	originalNodeId?: string | null;
	handles?: Prisma.HandleUncheckedCreateNestedManyWithoutNodeInput;
	edgesFrom?: Prisma.EdgeUncheckedCreateNestedManyWithoutSourceNodeInput;
	edgesTo?: Prisma.EdgeUncheckedCreateNestedManyWithoutTargetNodeInput;
	tasks?: Prisma.TaskUncheckedCreateNestedManyWithoutNodeInput;
	duplicates?: Prisma.NodeUncheckedCreateNestedManyWithoutOriginalNodeInput;
};

export type NodeCreateOrConnectWithoutCanvasInput = {
	where: Prisma.NodeWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.NodeCreateWithoutCanvasInput,
		Prisma.NodeUncheckedCreateWithoutCanvasInput
	>;
};

export type NodeCreateManyCanvasInputEnvelope = {
	data: Prisma.NodeCreateManyCanvasInput | Prisma.NodeCreateManyCanvasInput[];
	skipDuplicates?: boolean;
};

export type NodeUpsertWithWhereUniqueWithoutCanvasInput = {
	where: Prisma.NodeWhereUniqueInput;
	update: Prisma.XOR<
		Prisma.NodeUpdateWithoutCanvasInput,
		Prisma.NodeUncheckedUpdateWithoutCanvasInput
	>;
	create: Prisma.XOR<
		Prisma.NodeCreateWithoutCanvasInput,
		Prisma.NodeUncheckedCreateWithoutCanvasInput
	>;
};

export type NodeUpdateWithWhereUniqueWithoutCanvasInput = {
	where: Prisma.NodeWhereUniqueInput;
	data: Prisma.XOR<
		Prisma.NodeUpdateWithoutCanvasInput,
		Prisma.NodeUncheckedUpdateWithoutCanvasInput
	>;
};

export type NodeUpdateManyWithWhereWithoutCanvasInput = {
	where: Prisma.NodeScalarWhereInput;
	data: Prisma.XOR<
		Prisma.NodeUpdateManyMutationInput,
		Prisma.NodeUncheckedUpdateManyWithoutCanvasInput
	>;
};

export type NodeScalarWhereInput = {
	AND?: Prisma.NodeScalarWhereInput | Prisma.NodeScalarWhereInput[];
	OR?: Prisma.NodeScalarWhereInput[];
	NOT?: Prisma.NodeScalarWhereInput | Prisma.NodeScalarWhereInput[];
	id?: Prisma.StringFilter<"Node"> | string;
	name?: Prisma.StringFilter<"Node"> | string;
	type?: Prisma.EnumNodeTypeFilter<"Node"> | $Enums.NodeType;
	position?: Prisma.JsonFilter<"Node">;
	width?: Prisma.FloatNullableFilter<"Node"> | number | null;
	height?: Prisma.FloatNullableFilter<"Node"> | number | null;
	config?: Prisma.JsonNullableFilter<"Node">;
	isDirty?: Prisma.BoolFilter<"Node"> | boolean;
	result?: Prisma.JsonNullableFilter<"Node">;
	createdAt?: Prisma.DateTimeFilter<"Node"> | Date | string;
	updatedAt?: Prisma.DateTimeFilter<"Node"> | Date | string;
	canvasId?: Prisma.StringFilter<"Node"> | string;
	templateId?: Prisma.StringFilter<"Node"> | string;
	originalNodeId?: Prisma.StringNullableFilter<"Node"> | string | null;
};

export type NodeCreateWithoutDuplicatesInput = {
	id?: string;
	name: string;
	type: $Enums.NodeType;
	position: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: number | null;
	height?: number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	handles?: Prisma.HandleCreateNestedManyWithoutNodeInput;
	edgesFrom?: Prisma.EdgeCreateNestedManyWithoutSourceNodeInput;
	edgesTo?: Prisma.EdgeCreateNestedManyWithoutTargetNodeInput;
	canvas: Prisma.CanvasCreateNestedOneWithoutNodesInput;
	tasks?: Prisma.TaskCreateNestedManyWithoutNodeInput;
	template: Prisma.NodeTemplateCreateNestedOneWithoutNodesInput;
	originalNode?: Prisma.NodeCreateNestedOneWithoutDuplicatesInput;
};

export type NodeUncheckedCreateWithoutDuplicatesInput = {
	id?: string;
	name: string;
	type: $Enums.NodeType;
	position: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: number | null;
	height?: number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	canvasId: string;
	templateId: string;
	originalNodeId?: string | null;
	handles?: Prisma.HandleUncheckedCreateNestedManyWithoutNodeInput;
	edgesFrom?: Prisma.EdgeUncheckedCreateNestedManyWithoutSourceNodeInput;
	edgesTo?: Prisma.EdgeUncheckedCreateNestedManyWithoutTargetNodeInput;
	tasks?: Prisma.TaskUncheckedCreateNestedManyWithoutNodeInput;
};

export type NodeCreateOrConnectWithoutDuplicatesInput = {
	where: Prisma.NodeWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.NodeCreateWithoutDuplicatesInput,
		Prisma.NodeUncheckedCreateWithoutDuplicatesInput
	>;
};

export type NodeCreateWithoutOriginalNodeInput = {
	id?: string;
	name: string;
	type: $Enums.NodeType;
	position: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: number | null;
	height?: number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	handles?: Prisma.HandleCreateNestedManyWithoutNodeInput;
	edgesFrom?: Prisma.EdgeCreateNestedManyWithoutSourceNodeInput;
	edgesTo?: Prisma.EdgeCreateNestedManyWithoutTargetNodeInput;
	canvas: Prisma.CanvasCreateNestedOneWithoutNodesInput;
	tasks?: Prisma.TaskCreateNestedManyWithoutNodeInput;
	template: Prisma.NodeTemplateCreateNestedOneWithoutNodesInput;
	duplicates?: Prisma.NodeCreateNestedManyWithoutOriginalNodeInput;
};

export type NodeUncheckedCreateWithoutOriginalNodeInput = {
	id?: string;
	name: string;
	type: $Enums.NodeType;
	position: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: number | null;
	height?: number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	canvasId: string;
	templateId: string;
	handles?: Prisma.HandleUncheckedCreateNestedManyWithoutNodeInput;
	edgesFrom?: Prisma.EdgeUncheckedCreateNestedManyWithoutSourceNodeInput;
	edgesTo?: Prisma.EdgeUncheckedCreateNestedManyWithoutTargetNodeInput;
	tasks?: Prisma.TaskUncheckedCreateNestedManyWithoutNodeInput;
	duplicates?: Prisma.NodeUncheckedCreateNestedManyWithoutOriginalNodeInput;
};

export type NodeCreateOrConnectWithoutOriginalNodeInput = {
	where: Prisma.NodeWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.NodeCreateWithoutOriginalNodeInput,
		Prisma.NodeUncheckedCreateWithoutOriginalNodeInput
	>;
};

export type NodeCreateManyOriginalNodeInputEnvelope = {
	data:
		| Prisma.NodeCreateManyOriginalNodeInput
		| Prisma.NodeCreateManyOriginalNodeInput[];
	skipDuplicates?: boolean;
};

export type NodeUpsertWithoutDuplicatesInput = {
	update: Prisma.XOR<
		Prisma.NodeUpdateWithoutDuplicatesInput,
		Prisma.NodeUncheckedUpdateWithoutDuplicatesInput
	>;
	create: Prisma.XOR<
		Prisma.NodeCreateWithoutDuplicatesInput,
		Prisma.NodeUncheckedCreateWithoutDuplicatesInput
	>;
	where?: Prisma.NodeWhereInput;
};

export type NodeUpdateToOneWithWhereWithoutDuplicatesInput = {
	where?: Prisma.NodeWhereInput;
	data: Prisma.XOR<
		Prisma.NodeUpdateWithoutDuplicatesInput,
		Prisma.NodeUncheckedUpdateWithoutDuplicatesInput
	>;
};

export type NodeUpdateWithoutDuplicatesInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?: Prisma.EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType;
	position?: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	height?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	handles?: Prisma.HandleUpdateManyWithoutNodeNestedInput;
	edgesFrom?: Prisma.EdgeUpdateManyWithoutSourceNodeNestedInput;
	edgesTo?: Prisma.EdgeUpdateManyWithoutTargetNodeNestedInput;
	canvas?: Prisma.CanvasUpdateOneRequiredWithoutNodesNestedInput;
	tasks?: Prisma.TaskUpdateManyWithoutNodeNestedInput;
	template?: Prisma.NodeTemplateUpdateOneRequiredWithoutNodesNestedInput;
	originalNode?: Prisma.NodeUpdateOneWithoutDuplicatesNestedInput;
};

export type NodeUncheckedUpdateWithoutDuplicatesInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?: Prisma.EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType;
	position?: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	height?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	canvasId?: Prisma.StringFieldUpdateOperationsInput | string;
	templateId?: Prisma.StringFieldUpdateOperationsInput | string;
	originalNodeId?:
		| Prisma.NullableStringFieldUpdateOperationsInput
		| string
		| null;
	handles?: Prisma.HandleUncheckedUpdateManyWithoutNodeNestedInput;
	edgesFrom?: Prisma.EdgeUncheckedUpdateManyWithoutSourceNodeNestedInput;
	edgesTo?: Prisma.EdgeUncheckedUpdateManyWithoutTargetNodeNestedInput;
	tasks?: Prisma.TaskUncheckedUpdateManyWithoutNodeNestedInput;
};

export type NodeUpsertWithWhereUniqueWithoutOriginalNodeInput = {
	where: Prisma.NodeWhereUniqueInput;
	update: Prisma.XOR<
		Prisma.NodeUpdateWithoutOriginalNodeInput,
		Prisma.NodeUncheckedUpdateWithoutOriginalNodeInput
	>;
	create: Prisma.XOR<
		Prisma.NodeCreateWithoutOriginalNodeInput,
		Prisma.NodeUncheckedCreateWithoutOriginalNodeInput
	>;
};

export type NodeUpdateWithWhereUniqueWithoutOriginalNodeInput = {
	where: Prisma.NodeWhereUniqueInput;
	data: Prisma.XOR<
		Prisma.NodeUpdateWithoutOriginalNodeInput,
		Prisma.NodeUncheckedUpdateWithoutOriginalNodeInput
	>;
};

export type NodeUpdateManyWithWhereWithoutOriginalNodeInput = {
	where: Prisma.NodeScalarWhereInput;
	data: Prisma.XOR<
		Prisma.NodeUpdateManyMutationInput,
		Prisma.NodeUncheckedUpdateManyWithoutOriginalNodeInput
	>;
};

export type NodeCreateWithoutHandlesInput = {
	id?: string;
	name: string;
	type: $Enums.NodeType;
	position: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: number | null;
	height?: number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	edgesFrom?: Prisma.EdgeCreateNestedManyWithoutSourceNodeInput;
	edgesTo?: Prisma.EdgeCreateNestedManyWithoutTargetNodeInput;
	canvas: Prisma.CanvasCreateNestedOneWithoutNodesInput;
	tasks?: Prisma.TaskCreateNestedManyWithoutNodeInput;
	template: Prisma.NodeTemplateCreateNestedOneWithoutNodesInput;
	originalNode?: Prisma.NodeCreateNestedOneWithoutDuplicatesInput;
	duplicates?: Prisma.NodeCreateNestedManyWithoutOriginalNodeInput;
};

export type NodeUncheckedCreateWithoutHandlesInput = {
	id?: string;
	name: string;
	type: $Enums.NodeType;
	position: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: number | null;
	height?: number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	canvasId: string;
	templateId: string;
	originalNodeId?: string | null;
	edgesFrom?: Prisma.EdgeUncheckedCreateNestedManyWithoutSourceNodeInput;
	edgesTo?: Prisma.EdgeUncheckedCreateNestedManyWithoutTargetNodeInput;
	tasks?: Prisma.TaskUncheckedCreateNestedManyWithoutNodeInput;
	duplicates?: Prisma.NodeUncheckedCreateNestedManyWithoutOriginalNodeInput;
};

export type NodeCreateOrConnectWithoutHandlesInput = {
	where: Prisma.NodeWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.NodeCreateWithoutHandlesInput,
		Prisma.NodeUncheckedCreateWithoutHandlesInput
	>;
};

export type NodeUpsertWithoutHandlesInput = {
	update: Prisma.XOR<
		Prisma.NodeUpdateWithoutHandlesInput,
		Prisma.NodeUncheckedUpdateWithoutHandlesInput
	>;
	create: Prisma.XOR<
		Prisma.NodeCreateWithoutHandlesInput,
		Prisma.NodeUncheckedCreateWithoutHandlesInput
	>;
	where?: Prisma.NodeWhereInput;
};

export type NodeUpdateToOneWithWhereWithoutHandlesInput = {
	where?: Prisma.NodeWhereInput;
	data: Prisma.XOR<
		Prisma.NodeUpdateWithoutHandlesInput,
		Prisma.NodeUncheckedUpdateWithoutHandlesInput
	>;
};

export type NodeUpdateWithoutHandlesInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?: Prisma.EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType;
	position?: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	height?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	edgesFrom?: Prisma.EdgeUpdateManyWithoutSourceNodeNestedInput;
	edgesTo?: Prisma.EdgeUpdateManyWithoutTargetNodeNestedInput;
	canvas?: Prisma.CanvasUpdateOneRequiredWithoutNodesNestedInput;
	tasks?: Prisma.TaskUpdateManyWithoutNodeNestedInput;
	template?: Prisma.NodeTemplateUpdateOneRequiredWithoutNodesNestedInput;
	originalNode?: Prisma.NodeUpdateOneWithoutDuplicatesNestedInput;
	duplicates?: Prisma.NodeUpdateManyWithoutOriginalNodeNestedInput;
};

export type NodeUncheckedUpdateWithoutHandlesInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?: Prisma.EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType;
	position?: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	height?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	canvasId?: Prisma.StringFieldUpdateOperationsInput | string;
	templateId?: Prisma.StringFieldUpdateOperationsInput | string;
	originalNodeId?:
		| Prisma.NullableStringFieldUpdateOperationsInput
		| string
		| null;
	edgesFrom?: Prisma.EdgeUncheckedUpdateManyWithoutSourceNodeNestedInput;
	edgesTo?: Prisma.EdgeUncheckedUpdateManyWithoutTargetNodeNestedInput;
	tasks?: Prisma.TaskUncheckedUpdateManyWithoutNodeNestedInput;
	duplicates?: Prisma.NodeUncheckedUpdateManyWithoutOriginalNodeNestedInput;
};

export type NodeCreateWithoutTemplateInput = {
	id?: string;
	name: string;
	type: $Enums.NodeType;
	position: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: number | null;
	height?: number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	handles?: Prisma.HandleCreateNestedManyWithoutNodeInput;
	edgesFrom?: Prisma.EdgeCreateNestedManyWithoutSourceNodeInput;
	edgesTo?: Prisma.EdgeCreateNestedManyWithoutTargetNodeInput;
	canvas: Prisma.CanvasCreateNestedOneWithoutNodesInput;
	tasks?: Prisma.TaskCreateNestedManyWithoutNodeInput;
	originalNode?: Prisma.NodeCreateNestedOneWithoutDuplicatesInput;
	duplicates?: Prisma.NodeCreateNestedManyWithoutOriginalNodeInput;
};

export type NodeUncheckedCreateWithoutTemplateInput = {
	id?: string;
	name: string;
	type: $Enums.NodeType;
	position: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: number | null;
	height?: number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	canvasId: string;
	originalNodeId?: string | null;
	handles?: Prisma.HandleUncheckedCreateNestedManyWithoutNodeInput;
	edgesFrom?: Prisma.EdgeUncheckedCreateNestedManyWithoutSourceNodeInput;
	edgesTo?: Prisma.EdgeUncheckedCreateNestedManyWithoutTargetNodeInput;
	tasks?: Prisma.TaskUncheckedCreateNestedManyWithoutNodeInput;
	duplicates?: Prisma.NodeUncheckedCreateNestedManyWithoutOriginalNodeInput;
};

export type NodeCreateOrConnectWithoutTemplateInput = {
	where: Prisma.NodeWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.NodeCreateWithoutTemplateInput,
		Prisma.NodeUncheckedCreateWithoutTemplateInput
	>;
};

export type NodeCreateManyTemplateInputEnvelope = {
	data:
		| Prisma.NodeCreateManyTemplateInput
		| Prisma.NodeCreateManyTemplateInput[];
	skipDuplicates?: boolean;
};

export type NodeUpsertWithWhereUniqueWithoutTemplateInput = {
	where: Prisma.NodeWhereUniqueInput;
	update: Prisma.XOR<
		Prisma.NodeUpdateWithoutTemplateInput,
		Prisma.NodeUncheckedUpdateWithoutTemplateInput
	>;
	create: Prisma.XOR<
		Prisma.NodeCreateWithoutTemplateInput,
		Prisma.NodeUncheckedCreateWithoutTemplateInput
	>;
};

export type NodeUpdateWithWhereUniqueWithoutTemplateInput = {
	where: Prisma.NodeWhereUniqueInput;
	data: Prisma.XOR<
		Prisma.NodeUpdateWithoutTemplateInput,
		Prisma.NodeUncheckedUpdateWithoutTemplateInput
	>;
};

export type NodeUpdateManyWithWhereWithoutTemplateInput = {
	where: Prisma.NodeScalarWhereInput;
	data: Prisma.XOR<
		Prisma.NodeUpdateManyMutationInput,
		Prisma.NodeUncheckedUpdateManyWithoutTemplateInput
	>;
};

export type NodeCreateWithoutEdgesFromInput = {
	id?: string;
	name: string;
	type: $Enums.NodeType;
	position: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: number | null;
	height?: number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	handles?: Prisma.HandleCreateNestedManyWithoutNodeInput;
	edgesTo?: Prisma.EdgeCreateNestedManyWithoutTargetNodeInput;
	canvas: Prisma.CanvasCreateNestedOneWithoutNodesInput;
	tasks?: Prisma.TaskCreateNestedManyWithoutNodeInput;
	template: Prisma.NodeTemplateCreateNestedOneWithoutNodesInput;
	originalNode?: Prisma.NodeCreateNestedOneWithoutDuplicatesInput;
	duplicates?: Prisma.NodeCreateNestedManyWithoutOriginalNodeInput;
};

export type NodeUncheckedCreateWithoutEdgesFromInput = {
	id?: string;
	name: string;
	type: $Enums.NodeType;
	position: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: number | null;
	height?: number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	canvasId: string;
	templateId: string;
	originalNodeId?: string | null;
	handles?: Prisma.HandleUncheckedCreateNestedManyWithoutNodeInput;
	edgesTo?: Prisma.EdgeUncheckedCreateNestedManyWithoutTargetNodeInput;
	tasks?: Prisma.TaskUncheckedCreateNestedManyWithoutNodeInput;
	duplicates?: Prisma.NodeUncheckedCreateNestedManyWithoutOriginalNodeInput;
};

export type NodeCreateOrConnectWithoutEdgesFromInput = {
	where: Prisma.NodeWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.NodeCreateWithoutEdgesFromInput,
		Prisma.NodeUncheckedCreateWithoutEdgesFromInput
	>;
};

export type NodeCreateWithoutEdgesToInput = {
	id?: string;
	name: string;
	type: $Enums.NodeType;
	position: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: number | null;
	height?: number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	handles?: Prisma.HandleCreateNestedManyWithoutNodeInput;
	edgesFrom?: Prisma.EdgeCreateNestedManyWithoutSourceNodeInput;
	canvas: Prisma.CanvasCreateNestedOneWithoutNodesInput;
	tasks?: Prisma.TaskCreateNestedManyWithoutNodeInput;
	template: Prisma.NodeTemplateCreateNestedOneWithoutNodesInput;
	originalNode?: Prisma.NodeCreateNestedOneWithoutDuplicatesInput;
	duplicates?: Prisma.NodeCreateNestedManyWithoutOriginalNodeInput;
};

export type NodeUncheckedCreateWithoutEdgesToInput = {
	id?: string;
	name: string;
	type: $Enums.NodeType;
	position: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: number | null;
	height?: number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	canvasId: string;
	templateId: string;
	originalNodeId?: string | null;
	handles?: Prisma.HandleUncheckedCreateNestedManyWithoutNodeInput;
	edgesFrom?: Prisma.EdgeUncheckedCreateNestedManyWithoutSourceNodeInput;
	tasks?: Prisma.TaskUncheckedCreateNestedManyWithoutNodeInput;
	duplicates?: Prisma.NodeUncheckedCreateNestedManyWithoutOriginalNodeInput;
};

export type NodeCreateOrConnectWithoutEdgesToInput = {
	where: Prisma.NodeWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.NodeCreateWithoutEdgesToInput,
		Prisma.NodeUncheckedCreateWithoutEdgesToInput
	>;
};

export type NodeUpsertWithoutEdgesFromInput = {
	update: Prisma.XOR<
		Prisma.NodeUpdateWithoutEdgesFromInput,
		Prisma.NodeUncheckedUpdateWithoutEdgesFromInput
	>;
	create: Prisma.XOR<
		Prisma.NodeCreateWithoutEdgesFromInput,
		Prisma.NodeUncheckedCreateWithoutEdgesFromInput
	>;
	where?: Prisma.NodeWhereInput;
};

export type NodeUpdateToOneWithWhereWithoutEdgesFromInput = {
	where?: Prisma.NodeWhereInput;
	data: Prisma.XOR<
		Prisma.NodeUpdateWithoutEdgesFromInput,
		Prisma.NodeUncheckedUpdateWithoutEdgesFromInput
	>;
};

export type NodeUpdateWithoutEdgesFromInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?: Prisma.EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType;
	position?: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	height?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	handles?: Prisma.HandleUpdateManyWithoutNodeNestedInput;
	edgesTo?: Prisma.EdgeUpdateManyWithoutTargetNodeNestedInput;
	canvas?: Prisma.CanvasUpdateOneRequiredWithoutNodesNestedInput;
	tasks?: Prisma.TaskUpdateManyWithoutNodeNestedInput;
	template?: Prisma.NodeTemplateUpdateOneRequiredWithoutNodesNestedInput;
	originalNode?: Prisma.NodeUpdateOneWithoutDuplicatesNestedInput;
	duplicates?: Prisma.NodeUpdateManyWithoutOriginalNodeNestedInput;
};

export type NodeUncheckedUpdateWithoutEdgesFromInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?: Prisma.EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType;
	position?: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	height?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	canvasId?: Prisma.StringFieldUpdateOperationsInput | string;
	templateId?: Prisma.StringFieldUpdateOperationsInput | string;
	originalNodeId?:
		| Prisma.NullableStringFieldUpdateOperationsInput
		| string
		| null;
	handles?: Prisma.HandleUncheckedUpdateManyWithoutNodeNestedInput;
	edgesTo?: Prisma.EdgeUncheckedUpdateManyWithoutTargetNodeNestedInput;
	tasks?: Prisma.TaskUncheckedUpdateManyWithoutNodeNestedInput;
	duplicates?: Prisma.NodeUncheckedUpdateManyWithoutOriginalNodeNestedInput;
};

export type NodeUpsertWithoutEdgesToInput = {
	update: Prisma.XOR<
		Prisma.NodeUpdateWithoutEdgesToInput,
		Prisma.NodeUncheckedUpdateWithoutEdgesToInput
	>;
	create: Prisma.XOR<
		Prisma.NodeCreateWithoutEdgesToInput,
		Prisma.NodeUncheckedCreateWithoutEdgesToInput
	>;
	where?: Prisma.NodeWhereInput;
};

export type NodeUpdateToOneWithWhereWithoutEdgesToInput = {
	where?: Prisma.NodeWhereInput;
	data: Prisma.XOR<
		Prisma.NodeUpdateWithoutEdgesToInput,
		Prisma.NodeUncheckedUpdateWithoutEdgesToInput
	>;
};

export type NodeUpdateWithoutEdgesToInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?: Prisma.EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType;
	position?: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	height?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	handles?: Prisma.HandleUpdateManyWithoutNodeNestedInput;
	edgesFrom?: Prisma.EdgeUpdateManyWithoutSourceNodeNestedInput;
	canvas?: Prisma.CanvasUpdateOneRequiredWithoutNodesNestedInput;
	tasks?: Prisma.TaskUpdateManyWithoutNodeNestedInput;
	template?: Prisma.NodeTemplateUpdateOneRequiredWithoutNodesNestedInput;
	originalNode?: Prisma.NodeUpdateOneWithoutDuplicatesNestedInput;
	duplicates?: Prisma.NodeUpdateManyWithoutOriginalNodeNestedInput;
};

export type NodeUncheckedUpdateWithoutEdgesToInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?: Prisma.EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType;
	position?: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	height?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	canvasId?: Prisma.StringFieldUpdateOperationsInput | string;
	templateId?: Prisma.StringFieldUpdateOperationsInput | string;
	originalNodeId?:
		| Prisma.NullableStringFieldUpdateOperationsInput
		| string
		| null;
	handles?: Prisma.HandleUncheckedUpdateManyWithoutNodeNestedInput;
	edgesFrom?: Prisma.EdgeUncheckedUpdateManyWithoutSourceNodeNestedInput;
	tasks?: Prisma.TaskUncheckedUpdateManyWithoutNodeNestedInput;
	duplicates?: Prisma.NodeUncheckedUpdateManyWithoutOriginalNodeNestedInput;
};

export type NodeCreateWithoutTasksInput = {
	id?: string;
	name: string;
	type: $Enums.NodeType;
	position: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: number | null;
	height?: number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	handles?: Prisma.HandleCreateNestedManyWithoutNodeInput;
	edgesFrom?: Prisma.EdgeCreateNestedManyWithoutSourceNodeInput;
	edgesTo?: Prisma.EdgeCreateNestedManyWithoutTargetNodeInput;
	canvas: Prisma.CanvasCreateNestedOneWithoutNodesInput;
	template: Prisma.NodeTemplateCreateNestedOneWithoutNodesInput;
	originalNode?: Prisma.NodeCreateNestedOneWithoutDuplicatesInput;
	duplicates?: Prisma.NodeCreateNestedManyWithoutOriginalNodeInput;
};

export type NodeUncheckedCreateWithoutTasksInput = {
	id?: string;
	name: string;
	type: $Enums.NodeType;
	position: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: number | null;
	height?: number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	canvasId: string;
	templateId: string;
	originalNodeId?: string | null;
	handles?: Prisma.HandleUncheckedCreateNestedManyWithoutNodeInput;
	edgesFrom?: Prisma.EdgeUncheckedCreateNestedManyWithoutSourceNodeInput;
	edgesTo?: Prisma.EdgeUncheckedCreateNestedManyWithoutTargetNodeInput;
	duplicates?: Prisma.NodeUncheckedCreateNestedManyWithoutOriginalNodeInput;
};

export type NodeCreateOrConnectWithoutTasksInput = {
	where: Prisma.NodeWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.NodeCreateWithoutTasksInput,
		Prisma.NodeUncheckedCreateWithoutTasksInput
	>;
};

export type NodeUpsertWithoutTasksInput = {
	update: Prisma.XOR<
		Prisma.NodeUpdateWithoutTasksInput,
		Prisma.NodeUncheckedUpdateWithoutTasksInput
	>;
	create: Prisma.XOR<
		Prisma.NodeCreateWithoutTasksInput,
		Prisma.NodeUncheckedCreateWithoutTasksInput
	>;
	where?: Prisma.NodeWhereInput;
};

export type NodeUpdateToOneWithWhereWithoutTasksInput = {
	where?: Prisma.NodeWhereInput;
	data: Prisma.XOR<
		Prisma.NodeUpdateWithoutTasksInput,
		Prisma.NodeUncheckedUpdateWithoutTasksInput
	>;
};

export type NodeUpdateWithoutTasksInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?: Prisma.EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType;
	position?: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	height?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	handles?: Prisma.HandleUpdateManyWithoutNodeNestedInput;
	edgesFrom?: Prisma.EdgeUpdateManyWithoutSourceNodeNestedInput;
	edgesTo?: Prisma.EdgeUpdateManyWithoutTargetNodeNestedInput;
	canvas?: Prisma.CanvasUpdateOneRequiredWithoutNodesNestedInput;
	template?: Prisma.NodeTemplateUpdateOneRequiredWithoutNodesNestedInput;
	originalNode?: Prisma.NodeUpdateOneWithoutDuplicatesNestedInput;
	duplicates?: Prisma.NodeUpdateManyWithoutOriginalNodeNestedInput;
};

export type NodeUncheckedUpdateWithoutTasksInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?: Prisma.EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType;
	position?: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	height?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	canvasId?: Prisma.StringFieldUpdateOperationsInput | string;
	templateId?: Prisma.StringFieldUpdateOperationsInput | string;
	originalNodeId?:
		| Prisma.NullableStringFieldUpdateOperationsInput
		| string
		| null;
	handles?: Prisma.HandleUncheckedUpdateManyWithoutNodeNestedInput;
	edgesFrom?: Prisma.EdgeUncheckedUpdateManyWithoutSourceNodeNestedInput;
	edgesTo?: Prisma.EdgeUncheckedUpdateManyWithoutTargetNodeNestedInput;
	duplicates?: Prisma.NodeUncheckedUpdateManyWithoutOriginalNodeNestedInput;
};

export type NodeCreateManyCanvasInput = {
	id?: string;
	name: string;
	type: $Enums.NodeType;
	position: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: number | null;
	height?: number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	templateId: string;
	originalNodeId?: string | null;
};

export type NodeUpdateWithoutCanvasInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?: Prisma.EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType;
	position?: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	height?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	handles?: Prisma.HandleUpdateManyWithoutNodeNestedInput;
	edgesFrom?: Prisma.EdgeUpdateManyWithoutSourceNodeNestedInput;
	edgesTo?: Prisma.EdgeUpdateManyWithoutTargetNodeNestedInput;
	tasks?: Prisma.TaskUpdateManyWithoutNodeNestedInput;
	template?: Prisma.NodeTemplateUpdateOneRequiredWithoutNodesNestedInput;
	originalNode?: Prisma.NodeUpdateOneWithoutDuplicatesNestedInput;
	duplicates?: Prisma.NodeUpdateManyWithoutOriginalNodeNestedInput;
};

export type NodeUncheckedUpdateWithoutCanvasInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?: Prisma.EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType;
	position?: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	height?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	templateId?: Prisma.StringFieldUpdateOperationsInput | string;
	originalNodeId?:
		| Prisma.NullableStringFieldUpdateOperationsInput
		| string
		| null;
	handles?: Prisma.HandleUncheckedUpdateManyWithoutNodeNestedInput;
	edgesFrom?: Prisma.EdgeUncheckedUpdateManyWithoutSourceNodeNestedInput;
	edgesTo?: Prisma.EdgeUncheckedUpdateManyWithoutTargetNodeNestedInput;
	tasks?: Prisma.TaskUncheckedUpdateManyWithoutNodeNestedInput;
	duplicates?: Prisma.NodeUncheckedUpdateManyWithoutOriginalNodeNestedInput;
};

export type NodeUncheckedUpdateManyWithoutCanvasInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?: Prisma.EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType;
	position?: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	height?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	templateId?: Prisma.StringFieldUpdateOperationsInput | string;
	originalNodeId?:
		| Prisma.NullableStringFieldUpdateOperationsInput
		| string
		| null;
};

export type NodeCreateManyOriginalNodeInput = {
	id?: string;
	name: string;
	type: $Enums.NodeType;
	position: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: number | null;
	height?: number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	canvasId: string;
	templateId: string;
};

export type NodeUpdateWithoutOriginalNodeInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?: Prisma.EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType;
	position?: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	height?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	handles?: Prisma.HandleUpdateManyWithoutNodeNestedInput;
	edgesFrom?: Prisma.EdgeUpdateManyWithoutSourceNodeNestedInput;
	edgesTo?: Prisma.EdgeUpdateManyWithoutTargetNodeNestedInput;
	canvas?: Prisma.CanvasUpdateOneRequiredWithoutNodesNestedInput;
	tasks?: Prisma.TaskUpdateManyWithoutNodeNestedInput;
	template?: Prisma.NodeTemplateUpdateOneRequiredWithoutNodesNestedInput;
	duplicates?: Prisma.NodeUpdateManyWithoutOriginalNodeNestedInput;
};

export type NodeUncheckedUpdateWithoutOriginalNodeInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?: Prisma.EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType;
	position?: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	height?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	canvasId?: Prisma.StringFieldUpdateOperationsInput | string;
	templateId?: Prisma.StringFieldUpdateOperationsInput | string;
	handles?: Prisma.HandleUncheckedUpdateManyWithoutNodeNestedInput;
	edgesFrom?: Prisma.EdgeUncheckedUpdateManyWithoutSourceNodeNestedInput;
	edgesTo?: Prisma.EdgeUncheckedUpdateManyWithoutTargetNodeNestedInput;
	tasks?: Prisma.TaskUncheckedUpdateManyWithoutNodeNestedInput;
	duplicates?: Prisma.NodeUncheckedUpdateManyWithoutOriginalNodeNestedInput;
};

export type NodeUncheckedUpdateManyWithoutOriginalNodeInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?: Prisma.EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType;
	position?: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	height?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	canvasId?: Prisma.StringFieldUpdateOperationsInput | string;
	templateId?: Prisma.StringFieldUpdateOperationsInput | string;
};

export type NodeCreateManyTemplateInput = {
	id?: string;
	name: string;
	type: $Enums.NodeType;
	position: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: number | null;
	height?: number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	canvasId: string;
	originalNodeId?: string | null;
};

export type NodeUpdateWithoutTemplateInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?: Prisma.EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType;
	position?: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	height?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	handles?: Prisma.HandleUpdateManyWithoutNodeNestedInput;
	edgesFrom?: Prisma.EdgeUpdateManyWithoutSourceNodeNestedInput;
	edgesTo?: Prisma.EdgeUpdateManyWithoutTargetNodeNestedInput;
	canvas?: Prisma.CanvasUpdateOneRequiredWithoutNodesNestedInput;
	tasks?: Prisma.TaskUpdateManyWithoutNodeNestedInput;
	originalNode?: Prisma.NodeUpdateOneWithoutDuplicatesNestedInput;
	duplicates?: Prisma.NodeUpdateManyWithoutOriginalNodeNestedInput;
};

export type NodeUncheckedUpdateWithoutTemplateInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?: Prisma.EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType;
	position?: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	height?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	canvasId?: Prisma.StringFieldUpdateOperationsInput | string;
	originalNodeId?:
		| Prisma.NullableStringFieldUpdateOperationsInput
		| string
		| null;
	handles?: Prisma.HandleUncheckedUpdateManyWithoutNodeNestedInput;
	edgesFrom?: Prisma.EdgeUncheckedUpdateManyWithoutSourceNodeNestedInput;
	edgesTo?: Prisma.EdgeUncheckedUpdateManyWithoutTargetNodeNestedInput;
	tasks?: Prisma.TaskUncheckedUpdateManyWithoutNodeNestedInput;
	duplicates?: Prisma.NodeUncheckedUpdateManyWithoutOriginalNodeNestedInput;
};

export type NodeUncheckedUpdateManyWithoutTemplateInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?: Prisma.EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType;
	position?: Prisma.JsonNullValueInput | runtime.InputJsonValue;
	width?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	height?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	config?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	isDirty?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	result?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	canvasId?: Prisma.StringFieldUpdateOperationsInput | string;
	originalNodeId?:
		| Prisma.NullableStringFieldUpdateOperationsInput
		| string
		| null;
};

/**
 * Count Type NodeCountOutputType
 */

export type NodeCountOutputType = {
	handles: number;
	edgesFrom: number;
	edgesTo: number;
	tasks: number;
	duplicates: number;
};

export type NodeCountOutputTypeSelect<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	handles?: boolean | NodeCountOutputTypeCountHandlesArgs;
	edgesFrom?: boolean | NodeCountOutputTypeCountEdgesFromArgs;
	edgesTo?: boolean | NodeCountOutputTypeCountEdgesToArgs;
	tasks?: boolean | NodeCountOutputTypeCountTasksArgs;
	duplicates?: boolean | NodeCountOutputTypeCountDuplicatesArgs;
};

/**
 * NodeCountOutputType without action
 */
export type NodeCountOutputTypeDefaultArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the NodeCountOutputType
	 */
	select?: Prisma.NodeCountOutputTypeSelect<ExtArgs> | null;
};

/**
 * NodeCountOutputType without action
 */
export type NodeCountOutputTypeCountHandlesArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.HandleWhereInput;
};

/**
 * NodeCountOutputType without action
 */
export type NodeCountOutputTypeCountEdgesFromArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.EdgeWhereInput;
};

/**
 * NodeCountOutputType without action
 */
export type NodeCountOutputTypeCountEdgesToArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.EdgeWhereInput;
};

/**
 * NodeCountOutputType without action
 */
export type NodeCountOutputTypeCountTasksArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.TaskWhereInput;
};

/**
 * NodeCountOutputType without action
 */
export type NodeCountOutputTypeCountDuplicatesArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.NodeWhereInput;
};

export type NodeSelect<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean;
		name?: boolean;
		type?: boolean;
		position?: boolean;
		width?: boolean;
		height?: boolean;
		config?: boolean;
		isDirty?: boolean;
		result?: boolean;
		createdAt?: boolean;
		updatedAt?: boolean;
		canvasId?: boolean;
		templateId?: boolean;
		originalNodeId?: boolean;
		handles?: boolean | Prisma.Node$handlesArgs<ExtArgs>;
		edgesFrom?: boolean | Prisma.Node$edgesFromArgs<ExtArgs>;
		edgesTo?: boolean | Prisma.Node$edgesToArgs<ExtArgs>;
		canvas?: boolean | Prisma.CanvasDefaultArgs<ExtArgs>;
		tasks?: boolean | Prisma.Node$tasksArgs<ExtArgs>;
		template?: boolean | Prisma.NodeTemplateDefaultArgs<ExtArgs>;
		originalNode?: boolean | Prisma.Node$originalNodeArgs<ExtArgs>;
		duplicates?: boolean | Prisma.Node$duplicatesArgs<ExtArgs>;
		_count?: boolean | Prisma.NodeCountOutputTypeDefaultArgs<ExtArgs>;
	},
	ExtArgs["result"]["node"]
>;

export type NodeSelectCreateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean;
		name?: boolean;
		type?: boolean;
		position?: boolean;
		width?: boolean;
		height?: boolean;
		config?: boolean;
		isDirty?: boolean;
		result?: boolean;
		createdAt?: boolean;
		updatedAt?: boolean;
		canvasId?: boolean;
		templateId?: boolean;
		originalNodeId?: boolean;
		canvas?: boolean | Prisma.CanvasDefaultArgs<ExtArgs>;
		template?: boolean | Prisma.NodeTemplateDefaultArgs<ExtArgs>;
		originalNode?: boolean | Prisma.Node$originalNodeArgs<ExtArgs>;
	},
	ExtArgs["result"]["node"]
>;

export type NodeSelectUpdateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean;
		name?: boolean;
		type?: boolean;
		position?: boolean;
		width?: boolean;
		height?: boolean;
		config?: boolean;
		isDirty?: boolean;
		result?: boolean;
		createdAt?: boolean;
		updatedAt?: boolean;
		canvasId?: boolean;
		templateId?: boolean;
		originalNodeId?: boolean;
		canvas?: boolean | Prisma.CanvasDefaultArgs<ExtArgs>;
		template?: boolean | Prisma.NodeTemplateDefaultArgs<ExtArgs>;
		originalNode?: boolean | Prisma.Node$originalNodeArgs<ExtArgs>;
	},
	ExtArgs["result"]["node"]
>;

export type NodeSelectScalar = {
	id?: boolean;
	name?: boolean;
	type?: boolean;
	position?: boolean;
	width?: boolean;
	height?: boolean;
	config?: boolean;
	isDirty?: boolean;
	result?: boolean;
	createdAt?: boolean;
	updatedAt?: boolean;
	canvasId?: boolean;
	templateId?: boolean;
	originalNodeId?: boolean;
};

export type NodeOmit<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetOmit<
	| "id"
	| "name"
	| "type"
	| "position"
	| "width"
	| "height"
	| "config"
	| "isDirty"
	| "result"
	| "createdAt"
	| "updatedAt"
	| "canvasId"
	| "templateId"
	| "originalNodeId",
	ExtArgs["result"]["node"]
>;
export type NodeInclude<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	handles?: boolean | Prisma.Node$handlesArgs<ExtArgs>;
	edgesFrom?: boolean | Prisma.Node$edgesFromArgs<ExtArgs>;
	edgesTo?: boolean | Prisma.Node$edgesToArgs<ExtArgs>;
	canvas?: boolean | Prisma.CanvasDefaultArgs<ExtArgs>;
	tasks?: boolean | Prisma.Node$tasksArgs<ExtArgs>;
	template?: boolean | Prisma.NodeTemplateDefaultArgs<ExtArgs>;
	originalNode?: boolean | Prisma.Node$originalNodeArgs<ExtArgs>;
	duplicates?: boolean | Prisma.Node$duplicatesArgs<ExtArgs>;
	_count?: boolean | Prisma.NodeCountOutputTypeDefaultArgs<ExtArgs>;
};
export type NodeIncludeCreateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	canvas?: boolean | Prisma.CanvasDefaultArgs<ExtArgs>;
	template?: boolean | Prisma.NodeTemplateDefaultArgs<ExtArgs>;
	originalNode?: boolean | Prisma.Node$originalNodeArgs<ExtArgs>;
};
export type NodeIncludeUpdateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	canvas?: boolean | Prisma.CanvasDefaultArgs<ExtArgs>;
	template?: boolean | Prisma.NodeTemplateDefaultArgs<ExtArgs>;
	originalNode?: boolean | Prisma.Node$originalNodeArgs<ExtArgs>;
};

export type $NodePayload<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	name: "Node";
	objects: {
		handles: Prisma.$HandlePayload<ExtArgs>[];
		edgesFrom: Prisma.$EdgePayload<ExtArgs>[];
		edgesTo: Prisma.$EdgePayload<ExtArgs>[];
		canvas: Prisma.$CanvasPayload<ExtArgs>;
		tasks: Prisma.$TaskPayload<ExtArgs>[];
		template: Prisma.$NodeTemplatePayload<ExtArgs>;
		originalNode: Prisma.$NodePayload<ExtArgs> | null;
		duplicates: Prisma.$NodePayload<ExtArgs>[];
	};
	scalars: runtime.Types.Extensions.GetPayloadResult<
		{
			id: string;
			name: string;
			type: $Enums.NodeType;
			position: runtime.JsonValue;
			width: number | null;
			height: number | null;
			config: runtime.JsonValue | null;
			isDirty: boolean;
			/**
			 * OutputItem {
			 *     type: DataType;
			 *     data: FileData | string | boolean | number;
			 *     outputHandleId: string
			 *   }
			 *
			 *   Output {
			 *     items: OutputItem[]
			 *   }
			 *
			 *   Result {
			 *     selectedOutputIndex?: number
			 *     outputs: Output[];
			 *   }
			 */
			result: runtime.JsonValue | null;
			createdAt: Date;
			updatedAt: Date;
			canvasId: string;
			templateId: string;
			originalNodeId: string | null;
		},
		ExtArgs["result"]["node"]
	>;
	composites: {};
};

export type NodeGetPayload<
	S extends boolean | null | undefined | NodeDefaultArgs,
> = runtime.Types.Result.GetResult<Prisma.$NodePayload, S>;

export type NodeCountArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = Omit<NodeFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
	select?: NodeCountAggregateInputType | true;
};

export interface NodeDelegate<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {},
> {
	[K: symbol]: {
		types: Prisma.TypeMap<ExtArgs>["model"]["Node"];
		meta: { name: "Node" };
	};
	/**
	 * Find zero or one Node that matches the filter.
	 * @param {NodeFindUniqueArgs} args - Arguments to find a Node
	 * @example
	 * // Get one Node
	 * const node = await prisma.node.findUnique({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findUnique<T extends NodeFindUniqueArgs>(
		args: Prisma.SelectSubset<T, NodeFindUniqueArgs<ExtArgs>>,
	): Prisma.Prisma__NodeClient<
		runtime.Types.Result.GetResult<
			Prisma.$NodePayload<ExtArgs>,
			T,
			"findUnique",
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find one Node that matches the filter or throw an error with `error.code='P2025'`
	 * if no matches were found.
	 * @param {NodeFindUniqueOrThrowArgs} args - Arguments to find a Node
	 * @example
	 * // Get one Node
	 * const node = await prisma.node.findUniqueOrThrow({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findUniqueOrThrow<T extends NodeFindUniqueOrThrowArgs>(
		args: Prisma.SelectSubset<T, NodeFindUniqueOrThrowArgs<ExtArgs>>,
	): Prisma.Prisma__NodeClient<
		runtime.Types.Result.GetResult<
			Prisma.$NodePayload<ExtArgs>,
			T,
			"findUniqueOrThrow",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find the first Node that matches the filter.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {NodeFindFirstArgs} args - Arguments to find a Node
	 * @example
	 * // Get one Node
	 * const node = await prisma.node.findFirst({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findFirst<T extends NodeFindFirstArgs>(
		args?: Prisma.SelectSubset<T, NodeFindFirstArgs<ExtArgs>>,
	): Prisma.Prisma__NodeClient<
		runtime.Types.Result.GetResult<
			Prisma.$NodePayload<ExtArgs>,
			T,
			"findFirst",
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find the first Node that matches the filter or
	 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {NodeFindFirstOrThrowArgs} args - Arguments to find a Node
	 * @example
	 * // Get one Node
	 * const node = await prisma.node.findFirstOrThrow({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findFirstOrThrow<T extends NodeFindFirstOrThrowArgs>(
		args?: Prisma.SelectSubset<T, NodeFindFirstOrThrowArgs<ExtArgs>>,
	): Prisma.Prisma__NodeClient<
		runtime.Types.Result.GetResult<
			Prisma.$NodePayload<ExtArgs>,
			T,
			"findFirstOrThrow",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find zero or more Nodes that matches the filter.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {NodeFindManyArgs} args - Arguments to filter and select certain fields only.
	 * @example
	 * // Get all Nodes
	 * const nodes = await prisma.node.findMany()
	 *
	 * // Get first 10 Nodes
	 * const nodes = await prisma.node.findMany({ take: 10 })
	 *
	 * // Only select the `id`
	 * const nodeWithIdOnly = await prisma.node.findMany({ select: { id: true } })
	 *
	 */
	findMany<T extends NodeFindManyArgs>(
		args?: Prisma.SelectSubset<T, NodeFindManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$NodePayload<ExtArgs>,
			T,
			"findMany",
			GlobalOmitOptions
		>
	>;

	/**
	 * Create a Node.
	 * @param {NodeCreateArgs} args - Arguments to create a Node.
	 * @example
	 * // Create one Node
	 * const Node = await prisma.node.create({
	 *   data: {
	 *     // ... data to create a Node
	 *   }
	 * })
	 *
	 */
	create<T extends NodeCreateArgs>(
		args: Prisma.SelectSubset<T, NodeCreateArgs<ExtArgs>>,
	): Prisma.Prisma__NodeClient<
		runtime.Types.Result.GetResult<
			Prisma.$NodePayload<ExtArgs>,
			T,
			"create",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Create many Nodes.
	 * @param {NodeCreateManyArgs} args - Arguments to create many Nodes.
	 * @example
	 * // Create many Nodes
	 * const node = await prisma.node.createMany({
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 */
	createMany<T extends NodeCreateManyArgs>(
		args?: Prisma.SelectSubset<T, NodeCreateManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Create many Nodes and returns the data saved in the database.
	 * @param {NodeCreateManyAndReturnArgs} args - Arguments to create many Nodes.
	 * @example
	 * // Create many Nodes
	 * const node = await prisma.node.createManyAndReturn({
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 * // Create many Nodes and only return the `id`
	 * const nodeWithIdOnly = await prisma.node.createManyAndReturn({
	 *   select: { id: true },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 *
	 */
	createManyAndReturn<T extends NodeCreateManyAndReturnArgs>(
		args?: Prisma.SelectSubset<T, NodeCreateManyAndReturnArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$NodePayload<ExtArgs>,
			T,
			"createManyAndReturn",
			GlobalOmitOptions
		>
	>;

	/**
	 * Delete a Node.
	 * @param {NodeDeleteArgs} args - Arguments to delete one Node.
	 * @example
	 * // Delete one Node
	 * const Node = await prisma.node.delete({
	 *   where: {
	 *     // ... filter to delete one Node
	 *   }
	 * })
	 *
	 */
	delete<T extends NodeDeleteArgs>(
		args: Prisma.SelectSubset<T, NodeDeleteArgs<ExtArgs>>,
	): Prisma.Prisma__NodeClient<
		runtime.Types.Result.GetResult<
			Prisma.$NodePayload<ExtArgs>,
			T,
			"delete",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Update one Node.
	 * @param {NodeUpdateArgs} args - Arguments to update one Node.
	 * @example
	 * // Update one Node
	 * const node = await prisma.node.update({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: {
	 *     // ... provide data here
	 *   }
	 * })
	 *
	 */
	update<T extends NodeUpdateArgs>(
		args: Prisma.SelectSubset<T, NodeUpdateArgs<ExtArgs>>,
	): Prisma.Prisma__NodeClient<
		runtime.Types.Result.GetResult<
			Prisma.$NodePayload<ExtArgs>,
			T,
			"update",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Delete zero or more Nodes.
	 * @param {NodeDeleteManyArgs} args - Arguments to filter Nodes to delete.
	 * @example
	 * // Delete a few Nodes
	 * const { count } = await prisma.node.deleteMany({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 *
	 */
	deleteMany<T extends NodeDeleteManyArgs>(
		args?: Prisma.SelectSubset<T, NodeDeleteManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Update zero or more Nodes.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {NodeUpdateManyArgs} args - Arguments to update one or more rows.
	 * @example
	 * // Update many Nodes
	 * const node = await prisma.node.updateMany({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: {
	 *     // ... provide data here
	 *   }
	 * })
	 *
	 */
	updateMany<T extends NodeUpdateManyArgs>(
		args: Prisma.SelectSubset<T, NodeUpdateManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Update zero or more Nodes and returns the data updated in the database.
	 * @param {NodeUpdateManyAndReturnArgs} args - Arguments to update many Nodes.
	 * @example
	 * // Update many Nodes
	 * const node = await prisma.node.updateManyAndReturn({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 * // Update zero or more Nodes and only return the `id`
	 * const nodeWithIdOnly = await prisma.node.updateManyAndReturn({
	 *   select: { id: true },
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 *
	 */
	updateManyAndReturn<T extends NodeUpdateManyAndReturnArgs>(
		args: Prisma.SelectSubset<T, NodeUpdateManyAndReturnArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$NodePayload<ExtArgs>,
			T,
			"updateManyAndReturn",
			GlobalOmitOptions
		>
	>;

	/**
	 * Create or update one Node.
	 * @param {NodeUpsertArgs} args - Arguments to update or create a Node.
	 * @example
	 * // Update or create a Node
	 * const node = await prisma.node.upsert({
	 *   create: {
	 *     // ... data to create a Node
	 *   },
	 *   update: {
	 *     // ... in case it already exists, update
	 *   },
	 *   where: {
	 *     // ... the filter for the Node we want to update
	 *   }
	 * })
	 */
	upsert<T extends NodeUpsertArgs>(
		args: Prisma.SelectSubset<T, NodeUpsertArgs<ExtArgs>>,
	): Prisma.Prisma__NodeClient<
		runtime.Types.Result.GetResult<
			Prisma.$NodePayload<ExtArgs>,
			T,
			"upsert",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Count the number of Nodes.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {NodeCountArgs} args - Arguments to filter Nodes to count.
	 * @example
	 * // Count the number of Nodes
	 * const count = await prisma.node.count({
	 *   where: {
	 *     // ... the filter for the Nodes we want to count
	 *   }
	 * })
	 **/
	count<T extends NodeCountArgs>(
		args?: Prisma.Subset<T, NodeCountArgs>,
	): Prisma.PrismaPromise<
		T extends runtime.Types.Utils.Record<"select", any>
			? T["select"] extends true
				? number
				: Prisma.GetScalarType<T["select"], NodeCountAggregateOutputType>
			: number
	>;

	/**
	 * Allows you to perform aggregations operations on a Node.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {NodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
	 * @example
	 * // Ordered by age ascending
	 * // Where email contains prisma.io
	 * // Limited to the 10 users
	 * const aggregations = await prisma.user.aggregate({
	 *   _avg: {
	 *     age: true,
	 *   },
	 *   where: {
	 *     email: {
	 *       contains: "prisma.io",
	 *     },
	 *   },
	 *   orderBy: {
	 *     age: "asc",
	 *   },
	 *   take: 10,
	 * })
	 **/
	aggregate<T extends NodeAggregateArgs>(
		args: Prisma.Subset<T, NodeAggregateArgs>,
	): Prisma.PrismaPromise<GetNodeAggregateType<T>>;

	/**
	 * Group by Node.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {NodeGroupByArgs} args - Group by arguments.
	 * @example
	 * // Group by city, order by createdAt, get count
	 * const result = await prisma.user.groupBy({
	 *   by: ['city', 'createdAt'],
	 *   orderBy: {
	 *     createdAt: true
	 *   },
	 *   _count: {
	 *     _all: true
	 *   },
	 * })
	 *
	 **/
	groupBy<
		T extends NodeGroupByArgs,
		HasSelectOrTake extends Prisma.Or<
			Prisma.Extends<"skip", Prisma.Keys<T>>,
			Prisma.Extends<"take", Prisma.Keys<T>>
		>,
		OrderByArg extends Prisma.True extends HasSelectOrTake
			? { orderBy: NodeGroupByArgs["orderBy"] }
			: { orderBy?: NodeGroupByArgs["orderBy"] },
		OrderFields extends Prisma.ExcludeUnderscoreKeys<
			Prisma.Keys<Prisma.MaybeTupleToUnion<T["orderBy"]>>
		>,
		ByFields extends Prisma.MaybeTupleToUnion<T["by"]>,
		ByValid extends Prisma.Has<ByFields, OrderFields>,
		HavingFields extends Prisma.GetHavingFields<T["having"]>,
		HavingValid extends Prisma.Has<ByFields, HavingFields>,
		ByEmpty extends T["by"] extends never[] ? Prisma.True : Prisma.False,
		InputErrors extends ByEmpty extends Prisma.True
			? `Error: "by" must not be empty.`
			: HavingValid extends Prisma.False
				? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
										Error,
										"Field ",
										P,
										` in "having" needs to be provided in "by"`,
									];
					}[HavingFields]
				: "take" extends Prisma.Keys<T>
					? "orderBy" extends Prisma.Keys<T>
						? ByValid extends Prisma.True
							? {}
							: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
								}[OrderFields]
						: 'Error: If you provide "take", you also need to provide "orderBy"'
					: "skip" extends Prisma.Keys<T>
						? "orderBy" extends Prisma.Keys<T>
							? ByValid extends Prisma.True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
									}[OrderFields]
							: 'Error: If you provide "skip", you also need to provide "orderBy"'
						: ByValid extends Prisma.True
							? {}
							: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
								}[OrderFields],
	>(
		args: Prisma.SubsetIntersection<T, NodeGroupByArgs, OrderByArg> &
			InputErrors,
	): {} extends InputErrors
		? GetNodeGroupByPayload<T>
		: Prisma.PrismaPromise<InputErrors>;
	/**
	 * Fields of the Node model
	 */
	readonly fields: NodeFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for Node.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__NodeClient<
	T,
	Null = never,
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {},
> extends Prisma.PrismaPromise<T> {
	readonly [Symbol.toStringTag]: "PrismaPromise";
	handles<T extends Prisma.Node$handlesArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.Node$handlesArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		| runtime.Types.Result.GetResult<
				Prisma.$HandlePayload<ExtArgs>,
				T,
				"findMany",
				GlobalOmitOptions
		  >
		| Null
	>;
	edgesFrom<T extends Prisma.Node$edgesFromArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.Node$edgesFromArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		| runtime.Types.Result.GetResult<
				Prisma.$EdgePayload<ExtArgs>,
				T,
				"findMany",
				GlobalOmitOptions
		  >
		| Null
	>;
	edgesTo<T extends Prisma.Node$edgesToArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.Node$edgesToArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		| runtime.Types.Result.GetResult<
				Prisma.$EdgePayload<ExtArgs>,
				T,
				"findMany",
				GlobalOmitOptions
		  >
		| Null
	>;
	canvas<T extends Prisma.CanvasDefaultArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.CanvasDefaultArgs<ExtArgs>>,
	): Prisma.Prisma__CanvasClient<
		| runtime.Types.Result.GetResult<
				Prisma.$CanvasPayload<ExtArgs>,
				T,
				"findUniqueOrThrow",
				GlobalOmitOptions
		  >
		| Null,
		Null,
		ExtArgs,
		GlobalOmitOptions
	>;
	tasks<T extends Prisma.Node$tasksArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.Node$tasksArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		| runtime.Types.Result.GetResult<
				Prisma.$TaskPayload<ExtArgs>,
				T,
				"findMany",
				GlobalOmitOptions
		  >
		| Null
	>;
	template<T extends Prisma.NodeTemplateDefaultArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.NodeTemplateDefaultArgs<ExtArgs>>,
	): Prisma.Prisma__NodeTemplateClient<
		| runtime.Types.Result.GetResult<
				Prisma.$NodeTemplatePayload<ExtArgs>,
				T,
				"findUniqueOrThrow",
				GlobalOmitOptions
		  >
		| Null,
		Null,
		ExtArgs,
		GlobalOmitOptions
	>;
	originalNode<T extends Prisma.Node$originalNodeArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.Node$originalNodeArgs<ExtArgs>>,
	): Prisma.Prisma__NodeClient<
		runtime.Types.Result.GetResult<
			Prisma.$NodePayload<ExtArgs>,
			T,
			"findUniqueOrThrow",
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>;
	duplicates<T extends Prisma.Node$duplicatesArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.Node$duplicatesArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		| runtime.Types.Result.GetResult<
				Prisma.$NodePayload<ExtArgs>,
				T,
				"findMany",
				GlobalOmitOptions
		  >
		| Null
	>;
	/**
	 * Attaches callbacks for the resolution and/or rejection of the Promise.
	 * @param onfulfilled The callback to execute when the Promise is resolved.
	 * @param onrejected The callback to execute when the Promise is rejected.
	 * @returns A Promise for the completion of which ever callback is executed.
	 */
	then<TResult1 = T, TResult2 = never>(
		onfulfilled?:
			| ((value: T) => TResult1 | PromiseLike<TResult1>)
			| undefined
			| null,
		onrejected?:
			| ((reason: any) => TResult2 | PromiseLike<TResult2>)
			| undefined
			| null,
	): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
	/**
	 * Attaches a callback for only the rejection of the Promise.
	 * @param onrejected The callback to execute when the Promise is rejected.
	 * @returns A Promise for the completion of the callback.
	 */
	catch<TResult = never>(
		onrejected?:
			| ((reason: any) => TResult | PromiseLike<TResult>)
			| undefined
			| null,
	): runtime.Types.Utils.JsPromise<T | TResult>;
	/**
	 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
	 * resolved value cannot be modified from the callback.
	 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
	 * @returns A Promise for the completion of the callback.
	 */
	finally(
		onfinally?: (() => void) | undefined | null,
	): runtime.Types.Utils.JsPromise<T>;
}

/**
 * Fields of the Node model
 */
export interface NodeFieldRefs {
	readonly id: Prisma.FieldRef<"Node", "String">;
	readonly name: Prisma.FieldRef<"Node", "String">;
	readonly type: Prisma.FieldRef<"Node", "NodeType">;
	readonly position: Prisma.FieldRef<"Node", "Json">;
	readonly width: Prisma.FieldRef<"Node", "Float">;
	readonly height: Prisma.FieldRef<"Node", "Float">;
	readonly config: Prisma.FieldRef<"Node", "Json">;
	readonly isDirty: Prisma.FieldRef<"Node", "Boolean">;
	readonly result: Prisma.FieldRef<"Node", "Json">;
	readonly createdAt: Prisma.FieldRef<"Node", "DateTime">;
	readonly updatedAt: Prisma.FieldRef<"Node", "DateTime">;
	readonly canvasId: Prisma.FieldRef<"Node", "String">;
	readonly templateId: Prisma.FieldRef<"Node", "String">;
	readonly originalNodeId: Prisma.FieldRef<"Node", "String">;
}

// Custom InputTypes
/**
 * Node findUnique
 */
export type NodeFindUniqueArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Node
	 */
	select?: Prisma.NodeSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Node
	 */
	omit?: Prisma.NodeOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.NodeInclude<ExtArgs> | null;
	/**
	 * Filter, which Node to fetch.
	 */
	where: Prisma.NodeWhereUniqueInput;
};

/**
 * Node findUniqueOrThrow
 */
export type NodeFindUniqueOrThrowArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Node
	 */
	select?: Prisma.NodeSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Node
	 */
	omit?: Prisma.NodeOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.NodeInclude<ExtArgs> | null;
	/**
	 * Filter, which Node to fetch.
	 */
	where: Prisma.NodeWhereUniqueInput;
};

/**
 * Node findFirst
 */
export type NodeFindFirstArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Node
	 */
	select?: Prisma.NodeSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Node
	 */
	omit?: Prisma.NodeOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.NodeInclude<ExtArgs> | null;
	/**
	 * Filter, which Node to fetch.
	 */
	where?: Prisma.NodeWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Nodes to fetch.
	 */
	orderBy?:
		| Prisma.NodeOrderByWithRelationInput
		| Prisma.NodeOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for searching for Nodes.
	 */
	cursor?: Prisma.NodeWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Nodes from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Nodes.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
	 *
	 * Filter by unique combinations of Nodes.
	 */
	distinct?: Prisma.NodeScalarFieldEnum | Prisma.NodeScalarFieldEnum[];
};

/**
 * Node findFirstOrThrow
 */
export type NodeFindFirstOrThrowArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Node
	 */
	select?: Prisma.NodeSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Node
	 */
	omit?: Prisma.NodeOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.NodeInclude<ExtArgs> | null;
	/**
	 * Filter, which Node to fetch.
	 */
	where?: Prisma.NodeWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Nodes to fetch.
	 */
	orderBy?:
		| Prisma.NodeOrderByWithRelationInput
		| Prisma.NodeOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for searching for Nodes.
	 */
	cursor?: Prisma.NodeWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Nodes from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Nodes.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
	 *
	 * Filter by unique combinations of Nodes.
	 */
	distinct?: Prisma.NodeScalarFieldEnum | Prisma.NodeScalarFieldEnum[];
};

/**
 * Node findMany
 */
export type NodeFindManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Node
	 */
	select?: Prisma.NodeSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Node
	 */
	omit?: Prisma.NodeOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.NodeInclude<ExtArgs> | null;
	/**
	 * Filter, which Nodes to fetch.
	 */
	where?: Prisma.NodeWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Nodes to fetch.
	 */
	orderBy?:
		| Prisma.NodeOrderByWithRelationInput
		| Prisma.NodeOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for listing Nodes.
	 */
	cursor?: Prisma.NodeWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Nodes from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Nodes.
	 */
	skip?: number;
	distinct?: Prisma.NodeScalarFieldEnum | Prisma.NodeScalarFieldEnum[];
};

/**
 * Node create
 */
export type NodeCreateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Node
	 */
	select?: Prisma.NodeSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Node
	 */
	omit?: Prisma.NodeOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.NodeInclude<ExtArgs> | null;
	/**
	 * The data needed to create a Node.
	 */
	data: Prisma.XOR<Prisma.NodeCreateInput, Prisma.NodeUncheckedCreateInput>;
};

/**
 * Node createMany
 */
export type NodeCreateManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * The data used to create many Nodes.
	 */
	data: Prisma.NodeCreateManyInput | Prisma.NodeCreateManyInput[];
	skipDuplicates?: boolean;
};

/**
 * Node createManyAndReturn
 */
export type NodeCreateManyAndReturnArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Node
	 */
	select?: Prisma.NodeSelectCreateManyAndReturn<ExtArgs> | null;
	/**
	 * Omit specific fields from the Node
	 */
	omit?: Prisma.NodeOmit<ExtArgs> | null;
	/**
	 * The data used to create many Nodes.
	 */
	data: Prisma.NodeCreateManyInput | Prisma.NodeCreateManyInput[];
	skipDuplicates?: boolean;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.NodeIncludeCreateManyAndReturn<ExtArgs> | null;
};

/**
 * Node update
 */
export type NodeUpdateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Node
	 */
	select?: Prisma.NodeSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Node
	 */
	omit?: Prisma.NodeOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.NodeInclude<ExtArgs> | null;
	/**
	 * The data needed to update a Node.
	 */
	data: Prisma.XOR<Prisma.NodeUpdateInput, Prisma.NodeUncheckedUpdateInput>;
	/**
	 * Choose, which Node to update.
	 */
	where: Prisma.NodeWhereUniqueInput;
};

/**
 * Node updateMany
 */
export type NodeUpdateManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * The data used to update Nodes.
	 */
	data: Prisma.XOR<
		Prisma.NodeUpdateManyMutationInput,
		Prisma.NodeUncheckedUpdateManyInput
	>;
	/**
	 * Filter which Nodes to update
	 */
	where?: Prisma.NodeWhereInput;
	/**
	 * Limit how many Nodes to update.
	 */
	limit?: number;
};

/**
 * Node updateManyAndReturn
 */
export type NodeUpdateManyAndReturnArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Node
	 */
	select?: Prisma.NodeSelectUpdateManyAndReturn<ExtArgs> | null;
	/**
	 * Omit specific fields from the Node
	 */
	omit?: Prisma.NodeOmit<ExtArgs> | null;
	/**
	 * The data used to update Nodes.
	 */
	data: Prisma.XOR<
		Prisma.NodeUpdateManyMutationInput,
		Prisma.NodeUncheckedUpdateManyInput
	>;
	/**
	 * Filter which Nodes to update
	 */
	where?: Prisma.NodeWhereInput;
	/**
	 * Limit how many Nodes to update.
	 */
	limit?: number;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.NodeIncludeUpdateManyAndReturn<ExtArgs> | null;
};

/**
 * Node upsert
 */
export type NodeUpsertArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Node
	 */
	select?: Prisma.NodeSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Node
	 */
	omit?: Prisma.NodeOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.NodeInclude<ExtArgs> | null;
	/**
	 * The filter to search for the Node to update in case it exists.
	 */
	where: Prisma.NodeWhereUniqueInput;
	/**
	 * In case the Node found by the `where` argument doesn't exist, create a new Node with this data.
	 */
	create: Prisma.XOR<Prisma.NodeCreateInput, Prisma.NodeUncheckedCreateInput>;
	/**
	 * In case the Node was found with the provided `where` argument, update it with this data.
	 */
	update: Prisma.XOR<Prisma.NodeUpdateInput, Prisma.NodeUncheckedUpdateInput>;
};

/**
 * Node delete
 */
export type NodeDeleteArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Node
	 */
	select?: Prisma.NodeSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Node
	 */
	omit?: Prisma.NodeOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.NodeInclude<ExtArgs> | null;
	/**
	 * Filter which Node to delete.
	 */
	where: Prisma.NodeWhereUniqueInput;
};

/**
 * Node deleteMany
 */
export type NodeDeleteManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Filter which Nodes to delete
	 */
	where?: Prisma.NodeWhereInput;
	/**
	 * Limit how many Nodes to delete.
	 */
	limit?: number;
};

/**
 * Node.handles
 */
export type Node$handlesArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Handle
	 */
	select?: Prisma.HandleSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Handle
	 */
	omit?: Prisma.HandleOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.HandleInclude<ExtArgs> | null;
	where?: Prisma.HandleWhereInput;
	orderBy?:
		| Prisma.HandleOrderByWithRelationInput
		| Prisma.HandleOrderByWithRelationInput[];
	cursor?: Prisma.HandleWhereUniqueInput;
	take?: number;
	skip?: number;
	distinct?: Prisma.HandleScalarFieldEnum | Prisma.HandleScalarFieldEnum[];
};

/**
 * Node.edgesFrom
 */
export type Node$edgesFromArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Edge
	 */
	select?: Prisma.EdgeSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Edge
	 */
	omit?: Prisma.EdgeOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.EdgeInclude<ExtArgs> | null;
	where?: Prisma.EdgeWhereInput;
	orderBy?:
		| Prisma.EdgeOrderByWithRelationInput
		| Prisma.EdgeOrderByWithRelationInput[];
	cursor?: Prisma.EdgeWhereUniqueInput;
	take?: number;
	skip?: number;
	distinct?: Prisma.EdgeScalarFieldEnum | Prisma.EdgeScalarFieldEnum[];
};

/**
 * Node.edgesTo
 */
export type Node$edgesToArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Edge
	 */
	select?: Prisma.EdgeSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Edge
	 */
	omit?: Prisma.EdgeOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.EdgeInclude<ExtArgs> | null;
	where?: Prisma.EdgeWhereInput;
	orderBy?:
		| Prisma.EdgeOrderByWithRelationInput
		| Prisma.EdgeOrderByWithRelationInput[];
	cursor?: Prisma.EdgeWhereUniqueInput;
	take?: number;
	skip?: number;
	distinct?: Prisma.EdgeScalarFieldEnum | Prisma.EdgeScalarFieldEnum[];
};

/**
 * Node.tasks
 */
export type Node$tasksArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Task
	 */
	select?: Prisma.TaskSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Task
	 */
	omit?: Prisma.TaskOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.TaskInclude<ExtArgs> | null;
	where?: Prisma.TaskWhereInput;
	orderBy?:
		| Prisma.TaskOrderByWithRelationInput
		| Prisma.TaskOrderByWithRelationInput[];
	cursor?: Prisma.TaskWhereUniqueInput;
	take?: number;
	skip?: number;
	distinct?: Prisma.TaskScalarFieldEnum | Prisma.TaskScalarFieldEnum[];
};

/**
 * Node.originalNode
 */
export type Node$originalNodeArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Node
	 */
	select?: Prisma.NodeSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Node
	 */
	omit?: Prisma.NodeOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.NodeInclude<ExtArgs> | null;
	where?: Prisma.NodeWhereInput;
};

/**
 * Node.duplicates
 */
export type Node$duplicatesArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Node
	 */
	select?: Prisma.NodeSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Node
	 */
	omit?: Prisma.NodeOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.NodeInclude<ExtArgs> | null;
	where?: Prisma.NodeWhereInput;
	orderBy?:
		| Prisma.NodeOrderByWithRelationInput
		| Prisma.NodeOrderByWithRelationInput[];
	cursor?: Prisma.NodeWhereUniqueInput;
	take?: number;
	skip?: number;
	distinct?: Prisma.NodeScalarFieldEnum | Prisma.NodeScalarFieldEnum[];
};

/**
 * Node without action
 */
export type NodeDefaultArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Node
	 */
	select?: Prisma.NodeSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Node
	 */
	omit?: Prisma.NodeOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.NodeInclude<ExtArgs> | null;
};
