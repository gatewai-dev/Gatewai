// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider        = "prisma-client"
  output          = "../generated/client"
}

datasource db {
  provider = "sqlite"
  url      = "file:./game.db"
}

enum NodeType {
  Text
  Preview
  File
  Export
  Toggle
  Crawler
  Resize
  Agent
  ThreeD
  Painter
  Blur
  Compositor
  Describer
  Router
  Note
  Number

  GPTImage1
  LLM
}

enum DataType {
  Text
  Number
  Boolean
  Image
  Video
  Audio
  File
  Mask

  VideoLayer // Video, Audio | Used By Dynamic Handles of Video Compositor Node(WIP)
  DesignLayer // Text, Image, Mask | Used By Dynamic Handles of Design Compositor Node(WIP)
  Any // For Input's that accept Any Data
}

enum TaskStatus {
  WAITING_FOR_DEPLOY
  QUEUED
  EXECUTING
  REATTEMPTING
  FROZEN
  COMPLETED
  CANCELED
  FAILED
  CRASHED
  INTERRUPTED
  SYSTEM_FAILURE
  DELAYED
  EXPIRED
  TIMED_OUT
}

enum ProcessEnvironment {
  Browser
  Server
}

enum HandleType {
  Input
  Output
}

model User {
  id            String    @id
  name          String
  email         String
  emailVerified Boolean
  image         String?
  createdAt     DateTime
  updatedAt     DateTime
  sessions      Session[]
  accounts      Account[]

  canvases      Canvas[]
  tasks         Task[]
  tokens        Int?
  fileAssets    FileAsset[]

  @@unique([email])
  @@map("user")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime
  updatedAt DateTime
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime

  @@map("account")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@map("verification")
}

model Node {
  id             String          @id @default(cuid())
  name           String
  type           NodeType
  // React Flow position
  position       Json           // To store position as { x: number, y: number }
  // React Flow dimensions (optional, can be auto-calculated)
  width          Float?
  height         Float?
  // React Flow specific properties
  draggable      Boolean         @default(true)
  selectable     Boolean         @default(true)
  deletable      Boolean         @default(true)

  config         Json?
  isDirty        Boolean         @default(false) // Whether or not previous results or data/config changed
  /*

  OutputItem {
    type: DataType;
    data: FileData | string | boolean | number;
    outputHandleId: string
  }

  Output {
    items: OutputItem[]
  }

  Result {
    selectedOutputIndex?: number
    outputs: Output[];
  }
  */
  result         Json?           // Node processing result
  // Visual properties
  zIndex         Int?            // For layering
  // Timestamps - DB managed
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  // Relationships
  handles        Handle[]        @relation("NodeHandles")
  edgesFrom      Edge[]          @relation("EdgesFrom")
  edgesTo        Edge[]          @relation("EdgesTo")
  canvas         Canvas          @relation(fields: [canvasId], references: [id], onDelete: Cascade)
  canvasId       String
  tasks          Task[]
  templateId     String
  template       NodeTemplate    @relation(fields: [templateId], references: [id], onDelete: Restrict)

  @@map("node")
}

model Handle {
  id                 String              @id @default(cuid())
  type               HandleType
  dataType           DataType
  label              String
  order              Int                 @default(0)
  required           Boolean             @default(false)
  templateHandleId   String?
  templateHandle     NodeTemplateHandle? @relation(fields: [templateHandleId], references: [id], onDelete: Restrict)
  nodeId             String
  node               Node                @relation("NodeHandles", fields: [nodeId], references: [id], onDelete: Cascade)
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  sourceEdges        Edge[]              @relation("SourceHandle")
  targetEdges        Edge[]              @relation("TargetHandle")

  @@map("handle")
}

model NodeTemplate {
  id                  String                 @id @default(cuid())
  type                NodeType               @unique
  displayName         String
  description         String?
  templateHandles     NodeTemplateHandle[]
  processEnvironment  ProcessEnvironment
  tokenPrice          Float?                 @default(0.0)
  variableInputs      Boolean                @default(false)
  variableOutputs     Boolean                @default(false)
  category            String?
  subcategory         String?
  showInQuickAccess   Boolean                @default(false)
  createdAt           DateTime               @default(now())
  updatedAt           DateTime               @updatedAt
  nodes               Node[]
  defaultConfig       Json?

  @@map("node_template")
}

model NodeTemplateHandle {
  id              String        @id @default(cuid())
  templateId      String
  template        NodeTemplate  @relation(fields: [templateId], references: [id], onDelete: Cascade)
  type            HandleType
  dataType        DataType
  label           String
  required        Boolean       @default(false)
  handles         Handle[]
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt

  @@map("node_template_handle")
}

model Edge {
  id               String       @id @default(cuid())
  source           String
  target           String
  sourceHandleId   String
  targetHandleId   String
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt

  sourceNode       Node         @relation("EdgesFrom", fields: [source], references: [id], onDelete: Cascade)
  targetNode       Node         @relation("EdgesTo", fields: [target], references: [id], onDelete: Cascade)
  sourceHandle     Handle       @relation("SourceHandle", fields: [sourceHandleId], references: [id], onDelete: Cascade)
  targetHandle     Handle       @relation("TargetHandle", fields: [targetHandleId], references: [id], onDelete: Cascade)

  // Unique constraint to prevent duplicate connections between same handles
  @@unique([sourceHandleId, targetHandleId])
  @@map("edge")
}

model Canvas {
  id             String       @id @default(cuid())
  name           String
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  nodes          Node[]
  aiSessions     AISession[]
  tasks          Task[]
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId         String

  @@map("canvas")
}

model AISession {
  id        String   @id @default(cuid())
  messages  Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  canvas    Canvas   @relation(fields: [canvasId], references: [id], onDelete: Cascade)
  canvasId  String

  @@map("aisession")
}

model Task {
  id              String       @id @default(cuid())
  name            String
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  // Relationships
  canvas          Canvas       @relation(fields: [canvasId], references: [id], onDelete: Cascade)
  canvasId        String

  node            Node?        @relation(fields: [nodeId], references: [id], onDelete: SetNull)
  nodeId          String?

  user            User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId          String
  status          TaskStatus?
  durationMs      Float?
  finishedAt      DateTime?
  expiredAt       DateTime?
  startedAt       DateTime?
  error           Json?
  isTest          Boolean     @default(false)

  @@map("task")
}

enum FileAssetType {
  Image
  Video
}
model FileAsset {
  id              String       @id @default(cuid())
  name            String
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  width           Int?
  height          Int?
  bucket          String
  mimeType        String
  key             String
  signedUrl       String?
  signedUrlExp    DateTime?

  user            User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId          String
}