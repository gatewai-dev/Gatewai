// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider        = "prisma-client"
  output          = "../generated/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum NodeType {
  Text
  TextMerger
  Preview
  File
  Export
  Toggle
  Crop
  Resize
  Agent
  Paint
  Blur
  Compositor
  Note
  Number
  Modulate

  LLM
  ImageGen
  VideoGen
  VideoGenFirstLastFrame
  VideoGenExtend
  VideoCompositor

  TextToSpeech
  SpeechToText
}

enum DataType {
  Text
  Number
  Boolean
  Image
  Video
  Audio
  File
  Mask
}

enum TaskStatus {
  QUEUED
  EXECUTING
  FAILED
  COMPLETED
}

enum HandleType {
  Input
  Output
}

model Node {
  id             String          @id @default(cuid())
  name           String
  type           NodeType
  // React Flow position
  position       Json           // To store position as { x: number, y: number }
  // React Flow dimensions (optional, can be auto-calculated)
  width          Float?
  height         Float?
  // React Flow specific properties
  draggable      Boolean         @default(true)
  selectable     Boolean         @default(true)
  deletable      Boolean         @default(true)

  config         Json?
  isDirty        Boolean         @default(false) // Whether or not previous results or data/config changed
  /*

  OutputItem {
    type: DataType;
    data: FileData | string | boolean | number;
    outputHandleId: string
  }

  Output {
    items: OutputItem[]
  }

  Result {
    selectedOutputIndex?: number
    outputs: Output[];
  }
  */
  result         Json?           // Node processing result
  // Visual properties
  zIndex         Int?            // For layering
  // Timestamps - DB managed
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  // Relationships
  handles        Handle[]        @relation("NodeHandles")
  edgesFrom      Edge[]          @relation("EdgesFrom")
  edgesTo        Edge[]          @relation("EdgesTo")
  canvas         Canvas          @relation(fields: [canvasId], references: [id], onDelete: Cascade)
  canvasId       String
  tasks          Task[]
  templateId     String
  template       NodeTemplate    @relation(fields: [templateId], references: [id], onDelete: Restrict)

  @@map("node")
}

model Handle {
  id                 String              @id @default(cuid())
  type               HandleType
  dataTypes          DataType[]
  label              String
  // Required for Agent nodes where handles can be dynamically added
  description        String?
  order              Int                 @default(0)
  required           Boolean             @default(false)
  templateHandleId   String?
  templateHandle     NodeTemplateHandle? @relation(fields: [templateHandleId], references: [id], onDelete: Restrict)
  nodeId             String
  node               Node                @relation("NodeHandles", fields: [nodeId], references: [id], onDelete: Cascade)
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  sourceEdges        Edge[]              @relation("SourceHandle")
  targetEdges        Edge[]              @relation("TargetHandle")

  @@map("handle")
}

model NodeTemplate {
  id                  String                 @id @default(cuid())
  type                NodeType               @unique
  displayName         String
  description         String?
  templateHandles     NodeTemplateHandle[]
  tokenPrice          Float?                 @default(0.0)
  variableInputs      Boolean                @default(false)
  variableOutputs     Boolean                @default(false)
  category            String?
  subcategory         String?
  showInQuickAccess   Boolean                @default(false)
  createdAt           DateTime               @default(now())
  updatedAt           DateTime               @updatedAt
  nodes               Node[]
  defaultConfig       Json?
  isTerminalNode      Boolean                @default(false)
  isTransient         Boolean @default(false)

  @@map("node_template")
}

model NodeTemplateHandle {
  id              String        @id @default(cuid())
  templateId      String
  template        NodeTemplate  @relation(fields: [templateId], references: [id], onDelete: Cascade)
  type            HandleType
  dataTypes        DataType[]
  label           String
  required        Boolean       @default(false)
  handles         Handle[]
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt

  @@map("node_template_handle")
}

model Edge {
  id               String       @id @default(cuid())
  source           String
  target           String
  sourceHandleId   String
  targetHandleId   String
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt

  sourceNode       Node         @relation("EdgesFrom", fields: [source], references: [id], onDelete: Cascade)
  targetNode       Node         @relation("EdgesTo", fields: [target], references: [id], onDelete: Cascade)
  sourceHandle     Handle       @relation("SourceHandle", fields: [sourceHandleId], references: [id], onDelete: Cascade)
  targetHandle     Handle       @relation("TargetHandle", fields: [targetHandleId], references: [id], onDelete: Cascade)

  // Unique constraint to prevent duplicate connections between same handles
  @@unique([sourceHandleId, targetHandleId])
  @@map("edge")
}

model Canvas {
  id             String       @id @default(cuid())
  name           String
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  nodes          Node[]
  aiSessions     AISession[]
  taskBatches    TaskBatch[]
  @@map("canvas")
}

model AISession {
  id        String   @id @default(cuid())
  messages  Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  canvas    Canvas   @relation(fields: [canvasId], references: [id], onDelete: Cascade)
  canvasId  String

  @@map("aisession")
}

model TaskBatch {
  id              String       @id @default(cuid())
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  tasks           Task[]
  canvas          Canvas       @relation(fields: [canvasId], references: [id], onDelete: Cascade)
  canvasId        String

  finishedAt      DateTime?

  @@map("taskBatch")
}

model Task {
  id              String       @id @default(cuid())
  name            String
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt

  node            Node?        @relation(fields: [nodeId], references: [id], onDelete: SetNull)
  nodeId          String?

  status          TaskStatus?
  durationMs      Float?
  finishedAt      DateTime?
  expiredAt       DateTime?
  startedAt       DateTime?
  error           Json?
  isTest          Boolean     @default(false)

  batch          TaskBatch       @relation(fields: [batchId], references: [id], onDelete: Cascade)
  batchId        String

  @@map("task")
}

enum FileAssetType {
  Image
  Video
}
model FileAsset {
  id              String       @id @default(cuid())
  name            String
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt

  width           Int?
  height          Int?
  bucket          String
  // File size
  size            Int
  mimeType        String
  key             String
  signedUrl       String?
  signedUrlExp    DateTime?

  // Whether or not user is uploaded (true) or AI generated/System generated (false)
  isUploaded      Boolean     @default(true)

  // Duration by milliseconds
  duration        Int?

  // Media metadata - optional
  metadata        Json?
  fps             Int?
}