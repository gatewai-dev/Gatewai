generator client {
  provider        = "prisma-client"
  output          = "../generated/client"
  binaryTargets = ["native", "debian-openssl-1.1.x", "linux-arm64-openssl-1.1.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum NodeType {
  Text
  TextMerger
  Preview
  File
  Export
  Crop
  Resize
  Paint
  Blur
  Compositor
  Note
  Modulate

  LLM
  ImageGen
  VideoGen
  VideoGenFirstLastFrame
  VideoGenExtend
  VideoCompositor

  TextToSpeech
  SpeechToText
}

enum DataType {
  Text
  Number
  Boolean
  Image
  Video
  Audio
}

enum TaskStatus {
  QUEUED
  EXECUTING
  FAILED
  COMPLETED
}

enum HandleType {
  Input
  Output
}

model User {
  id            String    @id
  name          String
  email         String
  emailVerified Boolean
  image         String?
  createdAt     DateTime
  updatedAt     DateTime
  sessions      Session[]
  accounts      Account[]
  canvases      Canvas[]       @relation("UserCanvases")
  assets        FileAsset[]    @relation("UserAssets")
  apiKeys       ApiKey[]

  @@unique([email])
  @@map("user")
}


model ApiKey {
  id          String    @id @default(cuid())
  key         String    @unique
  name        String?
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  start       String?
  prefix      String?
  
  permissions Json?
  metadata    Json?
  
  expiresAt   DateTime?
  lastUsedAt  DateTime?
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([userId])
  @@map("apikey")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime
  updatedAt DateTime
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime

  @@map("account")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@map("verification")
}


model Canvas {
  id               String       @id @default(cuid())
  name             String
  description      String?
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt
  userId           String?
  user             User?         @relation("UserCanvases", fields: [userId], references: [id], onDelete: Cascade)
  nodes            Node[]
  taskBatches      TaskBatch[]
  /**
    True for Duplicated canvases created for API requests.
  */
  isAPICanvas      Boolean?     @default(false)
  /**
    Version of the canvas. Introduced to "sync" AI agent and User patch requests
  */
  version          Int          @default(0)

  originalCanvasId String?
  originalCanvas   Canvas?      @relation("CanvasDuplicates", fields: [originalCanvasId], references: [id])
  duplicates       Canvas[]     @relation("CanvasDuplicates")

  agentSessions       AgentSession[]
  patches             CanvasPatch[]

  @@index([userId])
  @@map("canvas")
}

model Node {
  id             String          @id @default(cuid())
  name           String
  type           NodeType
  // React Flow position
  position       Json           // To store position as { x: number, y: number }
  // React Flow dimensions (optional, can be auto-calculated)
  width          Float?
  height         Float?

  config         Json?
  isDirty        Boolean         @default(false) // Whether or not previous results or data/config changed
  /*

  OutputItem {
    type: DataType;
    data: FileData | string | boolean | number;
    outputHandleId: string
  }

  Output {
    items: OutputItem[]
  }

  Result {
    selectedOutputIndex?: number
    outputs: Output[];
  }
  */
  result         Json?           // Node processing result
  // Timestamps - DB managed
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  // Relationships
  handles        Handle[]        @relation("NodeHandles")
  edgesFrom      Edge[]          @relation("EdgesFrom")
  edgesTo        Edge[]          @relation("EdgesTo")
  canvas         Canvas          @relation(fields: [canvasId], references: [id], onDelete: Cascade)
  canvasId       String
  tasks          Task[]
  templateId     String
  template       NodeTemplate    @relation(fields: [templateId], references: [id], onDelete: Restrict)

  originalNodeId String?
  originalNode   Node?           @relation("NodeDuplicates", fields: [originalNodeId], references: [id], onDelete: SetNull)
  duplicates     Node[]          @relation("NodeDuplicates")


  @@map("node")
}

model Handle {
  id                 String              @id @default(cuid())
  type               HandleType
  dataTypes          DataType[]
  label              String
  description        String?
  order              Int                 @default(0)
  required           Boolean             @default(false)
  templateHandleId   String?
  templateHandle     NodeTemplateHandle? @relation(fields: [templateHandleId], references: [id], onDelete: Restrict)
  nodeId             String
  node               Node                @relation("NodeHandles", fields: [nodeId], references: [id], onDelete: Cascade)
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  sourceEdges        Edge[]              @relation("SourceHandle")
  targetEdges        Edge[]              @relation("TargetHandle")

  @@map("handle")
}

model NodeTemplate {
  id                      String                 @id @default(cuid())
  type                    NodeType               @unique
  displayName             String
  description             String?
  templateHandles         NodeTemplateHandle[]
  tokenPrice              Float?                 @default(0.0)
  variableInputs          Boolean                @default(false)
  variableInputDataTypes  DataType[]
  variableOutputs         Boolean                @default(false)
  variableOutputDataTypes DataType[]
  category                String?
  subcategory             String?
  showInQuickAccess       Boolean                @default(false)
  createdAt               DateTime               @default(now())
  updatedAt               DateTime               @updatedAt
  nodes                   Node[]
  defaultConfig           Json?
  isTerminalNode          Boolean                @default(false)
  isTransient             Boolean @default(false)

  @@map("nodeTemplate")
}

model NodeTemplateHandle {
  id              String        @id @default(cuid())
  templateId      String
  template        NodeTemplate  @relation(fields: [templateId], references: [id], onDelete: Cascade)
  type            HandleType
  dataTypes       DataType[]
  label           String
  required        Boolean       @default(false)
  order           Int
  description     String?
  handles         Handle[]
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt

  @@map("nodeTemplateHandle")
}

model Edge {
  id               String       @id @default(cuid())
  source           String
  target           String
  sourceHandleId   String
  targetHandleId   String
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt

  sourceNode       Node         @relation("EdgesFrom", fields: [source], references: [id], onDelete: Cascade)
  targetNode       Node         @relation("EdgesTo", fields: [target], references: [id], onDelete: Cascade)
  sourceHandle     Handle       @relation("SourceHandle", fields: [sourceHandleId], references: [id], onDelete: Cascade)
  targetHandle     Handle       @relation("TargetHandle", fields: [targetHandleId], references: [id], onDelete: Cascade)

  // Unique constraint to prevent duplicate connections between same handles
  @@unique([sourceHandleId, targetHandleId])
  @@map("edge")
}


model TaskBatch {
  id              String       @id @default(cuid())
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  tasks           Task[]
  canvas          Canvas       @relation(fields: [canvasId], references: [id], onDelete: Cascade)
  canvasId        String

  finishedAt      DateTime?
  // When the batch actually started executing (first task dispatched)
  startedAt       DateTime?
  // Stores job data when batch is waiting for previous batch to complete
  pendingJobData  Json?

  @@map("taskBatch")
}

model Task {
  id              String       @id @default(cuid())
  name            String
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt

  node            Node?        @relation(fields: [nodeId], references: [id], onDelete: SetNull)
  nodeId          String?

  status          TaskStatus?
  durationMs      Float?
  finishedAt      DateTime?
  expiredAt       DateTime?
  startedAt       DateTime?
  error           Json?
  isTest          Boolean     @default(false)

  batch          TaskBatch    @relation(fields: [batchId], references: [id], onDelete: Cascade)
  batchId        String

  // Storing result for recovery - This field is not being used in frontend.
  result          Json?

  @@map("task")
}


model FileAsset {
  id              String       @id @default(cuid())
  name            String
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  userId          String?
  user            User?         @relation("UserAssets", fields: [userId], references: [id], onDelete: Cascade)

  width           Int?
  height          Int?
  bucket          String
  // File size
  size            Int
  mimeType        String
  key             String
  signedUrl       String?
  signedUrlExp    DateTime?

  // Whether or not user is uploaded (true) or AI generated/System generated (false)
  isUploaded      Boolean     @default(true)

  // Duration by milliseconds
  duration        Int?

  // Media metadata - optional
  metadata        Json?
  fps             Int?

  @@index([userId])
  @@map("fileAsset")
}



model AgentSession {
  id                String    @id @default(cuid())
  canvasId          String
  canvas            Canvas    @relation(fields: [canvasId], references: [id], onDelete: Cascade)
  events            Event[]

  // OpenAI thread ID if using Assistants API
  threadId          String?   @unique
  
  // Assistant configuration
  assistantId       String?
  
  // AI model used for this session
  model             String?
  
  // Session state
  status            SessionStatus @default(ACTIVE)
  
  // Metadata for the conversation (tools, instructions, etc.)
  metadata          Json?

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  patches           CanvasPatch[]

  @@index([canvasId])
  @@index([threadId])
  @@map("agent_session")
}

model Event {
  id              String        @id @default(cuid())
  agentSessionId  String
  agentSession    AgentSession  @relation(fields: [agentSessionId], references: [id], onDelete: Cascade)
  
  // Event type from OpenAI (thread.message.created, thread.run.step.completed, etc.)
  eventType       String
  
  // Role for message events
  role            EventRole?
  
  // Content can be text, tool calls, tool results, etc.
  content         Json
  
  // OpenAI specific IDs
  messageId       String?       // OpenAI message ID
  runId           String?       // OpenAI run ID
  stepId          String?       // OpenAI step ID
  
  // For tool calls
  toolCallId      String?
  toolName        String?
  
  // Token usage tracking
  promptTokens    Int?
  completionTokens Int?
  totalTokens     Int?
  
  // Additional metadata (annotations, citations, etc.)
  metadata        Json?
  
  // Status for async operations
  status          EventStatus?  @default(COMPLETED)
  
  createdAt       DateTime      @default(now())

  @@index([agentSessionId, createdAt])
  @@index([messageId])
  @@index([runId])
  @@index([eventType])
  @@map("event")
}

enum EventRole {
  USER
  ASSISTANT
  SYSTEM
  TOOL
}

enum EventStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
  CANCELLED
}

enum SessionStatus {
  ACTIVE
  COMPLETED
  FAILED
  EXPIRED
}

model CanvasPatch {
  id        String   @id @default(cuid())
  canvasId  String
  canvas    Canvas   @relation(fields: [canvasId], references: [id], onDelete: Cascade)
  
  // The proposed changes (JSON)
  patch     Json
  
  status    PatchStatus @default(PENDING)

  agentSessionId String?
  agentSession   AgentSession? @relation(fields: [agentSessionId], references: [id], onDelete: SetNull)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("canvas_patch")
}

enum PatchStatus {
  PENDING
  ACCEPTED
  REJECTED
}
