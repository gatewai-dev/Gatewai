import { prisma } from "@gatewai/db";
import type {
	BaseArtifactService,
	DeleteArtifactRequest,
	ListArtifactKeysRequest,
	ListVersionsRequest,
	LoadArtifactRequest,
	SaveArtifactRequest,
} from "@google/adk";
import type { Part } from "@google/genai";
import { ENV_CONFIG } from "../../../config.js";
import { logger } from "../../../logger.js";
import {
	deleteFromGCS,
	getFromGCS,
	listFromGCS,
	uploadToGCS,
} from "../../../utils/storage.js";

/**
 * Service to handle persistence of files generated by the AI Agent.
 * Implements Google ADK BaseArtifactService to store parts in GCS
 * and register them as FileAssets in the database.
 */
export class AgentNodeArtifactService implements BaseArtifactService {
	private bucketName: string;
	private basePath: string;

	constructor(bucketName: string = ENV_CONFIG.GCS_ASSETS_BUCKET) {
		this.bucketName = bucketName;
		this.basePath = "artifacts";
	}

	/**
	 * constructKey helper to create consistent GCS paths.
	 * Format: artifacts/{appName}/{userId}/{sessionId}/{filename}/{version}
	 */
	private constructPrefix(
		appName: string,
		userId: string,
		sessionId: string,
		filename: string,
	): string {
		return `${this.basePath}/${appName}/${userId}/${sessionId}/${filename}`;
	}

	/**
	 * Saves an artifact to the artifact service storage.
	 */
	async saveArtifact(request: SaveArtifactRequest): Promise<number> {
		const { appName, userId, sessionId, filename, artifact } = request;

		if (!artifact.inlineData || !artifact.inlineData.data) {
			throw new Error("Artifact does not contain inline data");
		}

		// 1. Determine the next version number
		// We query the DB to find the latest version for this specific artifact.
		// Using Prisma's JSON filtering capabilities on the metadata field.
		const latestAsset = await prisma.fileAsset.findFirst({
			where: {
				metadata: {
					path: ["adk_identifiers"],
					equals: { appName, userId, sessionId, filename },
				},
			},
			orderBy: {
				createdAt: "desc",
			},
		});

		let nextVersion = 0;
		if (
			latestAsset?.metadata &&
			typeof latestAsset.metadata === "object" &&
			"version" in latestAsset.metadata
		) {
			const currentVersion = latestAsset.metadata.version;
			if (typeof currentVersion === "number") {
				nextVersion = currentVersion + 1;
			}
		}

		// 2. Prepare Upload
		const mimeType = artifact.inlineData.mimeType || "application/octet-stream";
		const buffer = Buffer.from(artifact.inlineData.data, "base64");
		const prefix = this.constructPrefix(appName, userId, sessionId, filename);
		const storageKey = `${prefix}/${nextVersion}`;

		// 3. Upload to GCS
		await uploadToGCS(buffer, storageKey, mimeType, this.bucketName);

		// 4. Create FileAsset entity in DB
		await prisma.fileAsset.create({
			data: {
				name: filename,
				bucket: this.bucketName,
				key: storageKey,
				mimeType: mimeType,
				size: buffer.length,
				isUploaded: false, // AI Generated
				// Store ADK identifiers in metadata for querying/versioning
				metadata: {
					adk_identifiers: {
						appName,
						userId,
						sessionId,
						filename,
					},
					version: nextVersion,
					source: "AgentNodeArtifactService",
				},
			},
		});

		return nextVersion;
	}

	/**
	 * Gets an artifact from the artifact service storage.
	 */
	async loadArtifact(request: LoadArtifactRequest): Promise<Part | undefined> {
		const { appName, userId, sessionId, filename, version } = request;

		let versionToLoad = version;

		// If version is not provided, find the latest one
		if (versionToLoad === undefined) {
			const latestVersions = await this.listVersions({
				appName,
				userId,
				sessionId,
				filename,
			});
			if (latestVersions.length === 0) {
				return undefined;
			}
			// Sort descending to get the highest number
			versionToLoad = latestVersions.sort((a, b) => b - a)[0];
		}

		const prefix = this.constructPrefix(appName, userId, sessionId, filename);
		const storageKey = `${prefix}/${versionToLoad}`;

		try {
			// Retrieve from GCS
			const buffer = await getFromGCS(storageKey, this.bucketName);

			// Retrieve MimeType from DB
			const asset = await prisma.fileAsset.findFirst({
				where: { key: storageKey },
				select: { mimeType: true },
			});

			return {
				inlineData: {
					data: buffer.toString("base64"),
					mimeType: asset?.mimeType || "application/octet-stream",
				},
			};
		} catch (error) {
			logger.error(error);
			// If file doesn't exist in GCS, return undefined as per interface contract
			// You might want to check the specific error code (e.g. 404)
			return undefined;
		}
	}

	/**
	 * Lists all the artifact filenames within a session.
	 */
	async listArtifactKeys(request: ListArtifactKeysRequest): Promise<string[]> {
		const { appName, userId, sessionId } = request;

		// We query the DB for unique filenames in this session
		const assets = await prisma.fileAsset.findMany({
			where: {
				metadata: {
					path: ["adk_identifiers"],
					equals: { appName, userId, sessionId },
				},
			},
			select: {
				name: true,
			},
		});

		// De-duplicate names
		const distinctNames = new Set(assets.map((a) => a.name));
		return Array.from(distinctNames);
	}

	/**
	 * Deletes an artifact (all versions).
	 */
	async deleteArtifact(request: DeleteArtifactRequest): Promise<void> {
		const { appName, userId, sessionId, filename } = request;
		const prefix = this.constructPrefix(appName, userId, sessionId, filename);

		// 1. List all files in GCS with this prefix (all versions)
		// Note: The prefix in storage ends with the filename, subsequent chars are /{version}
		// effectively making the directory artifacts/.../filename/ the container for versions.
		const gcsFiles = await listFromGCS(`${prefix}/`, this.bucketName);

		// 2. Delete from GCS and DB
		await Promise.all(
			gcsFiles.map(async (fileKey) => {
				// Delete from GCS
				await deleteFromGCS(fileKey, this.bucketName);

				// Delete from DB
				await prisma.fileAsset.deleteMany({
					where: { key: fileKey },
				});
			}),
		);
	}

	/**
	 * Lists all versions of an artifact.
	 */
	async listVersions(request: ListVersionsRequest): Promise<number[]> {
		const { appName, userId, sessionId, filename } = request;

		// Query DB for all assets matching these identifiers
		const assets = await prisma.fileAsset.findMany({
			where: {
				metadata: {
					path: ["adk_identifiers"],
					equals: { appName, userId, sessionId, filename },
				},
			},
			select: {
				metadata: true,
			},
		});

		const versions: number[] = [];

		for (const asset of assets) {
			if (
				asset.metadata &&
				typeof asset.metadata === "object" &&
				"version" in asset.metadata
			) {
				const v = asset.metadata.version;
				if (typeof v === "number") {
					versions.push(v);
				}
			}
		}

		return versions.sort((a, b) => a - b);
	}
}
